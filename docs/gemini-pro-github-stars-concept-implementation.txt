A Technical Blueprint for a GitHub-Native Personal Star Curation System




Part I: System Architecture and Design Principles




1.1. Conceptual Overview & Data Flow


This document outlines the architectural design and implementation of a next-generation personal github-stars curation system. The system's core philosophy is a strict adherence to a "GitHub-First" principle: every component, from data ingestion and AI-driven analysis to workflow orchestration and error handling, leverages a native GitHub feature. It is designed to be fully automated, self-contained, and auditable, with zero dependencies on external scripts or third-party services.
The system operates on a continuous, cyclical data flow orchestrated entirely by GitHub Actions. This process transforms the simple act of a user starring a public repository into a structured, documented, and categorized entry within a personal collection.
The end-to-end data flow is as follows:
1. Trigger: The process initiates either on a predefined schedule (e.g., daily) or through manual invocation (workflow_dispatch).
2. Fetch: The workflow authenticates with the GitHub REST API using the built-in GITHUB_TOKEN and retrieves the user's complete list of public starred repositories. This step meticulously handles API pagination to ensure all stars are collected.1
3. Diff & Cache: The fetched list is compared against the central manifest file, repos.yml, to identify newly starred repositories or those that have been updated since the last sync. An intelligent caching mechanism, based on the manifest's hash, prevents redundant workflow runs when no changes have occurred, optimizing resource usage.3
4. Analyze (AI): For each new or updated repository, the workflow invokes the official GitHub Models API. This native AI endpoint is used to perform deep analysis of the repository's content, primarily its README file, to classify it, extract relevant tags, and assess documentation quality.
5. Update Manifest: The structured metadata generated by the AI—including categories, tags, and summaries—is programmatically written back to the repos.yml file. This commit represents a single, atomic update to the curated collection.
6. Generate Structure: The local workspace is systematically cleared and regenerated based on the updated manifest. This process creates a hierarchical directory structure and adds or updates the corresponding git submodules, ensuring the repository's state is a perfect reflection of the manifest.5
7. Propose Changes (PR): A GitHub Pull Request is automatically created, bundling all changes: the updated manifest, the new directory structure, the added submodules, and newly generated README.md files for each organizational folder.6
8. Review (AI & CI): The newly created pull request is programmatically assigned to the @github-copilot user, triggering the Copilot Coding Agent. This agent autonomously reviews the changes, particularly the generated documentation, and may push subsequent commits to improve them. Concurrently, a Continuous Integration (CI) check validates the manifest's schema and the integrity of the generated file structure.
9. Merge: If all CI checks pass and the auto_merge feature flag is enabled in the manifest, the pull request is configured to merge automatically upon receiving a green status. Otherwise, it awaits manual review and approval from the user.7
10. Error Handling: Any failure at any stage of this process—be it an API outage, a classification error, or a script failure—triggers the creation of a detailed GitHub Issue. This issue is automatically populated with logs and context, converting the failure into a trackable, assignable work item for manual intervention.9


1.2. The Manifest as an Idempotent State Machine


The architectural cornerstone of this system is the repos.yml file, which functions not merely as a list but as the declarative, single source of truth for the entire curated collection. This manifest-driven approach provides idempotency, auditability, and efficiency.
* Idempotency: The workflow is designed as a state reconciliation engine. On every run, it reads the desired state from repos.yml and ensures the repository's physical structure—its folders, submodules, and documentation—perfectly matches that state. This makes the workflow inherently safe to run repeatedly. If no changes are needed, no actions are taken. If a previous run failed midway, the next run will simply correct the state to match the manifest. This eliminates the need for complex state management or tracking databases.
* Auditability: Every modification to the curated collection, whether it's adding a new repository or updating its tags, is captured as a discrete commit to the repos.yml file. This provides a complete, version-controlled history of all curation activities, accessible directly through the repository's git history.
* Caching and Efficiency: The manifest contains a critical field for each repository entry: last_synced_sha. This field stores the commit SHA of the target repository at the time it was last processed. During the "Sync & Discover" phase, the workflow fetches the latest SHA for each repository and compares it to the value in the manifest. If the SHAs match, the repository has not been updated, and it is skipped for AI analysis, saving significant processing time and API calls.10 This per-repo caching is far more granular and efficient than simply caching the entire workflow run.


1.3. The GitHub-Native Automation Loop


This system exemplifies a virtuous cycle of automation built exclusively from native GitHub components, ensuring long-term stability and maintainability by avoiding brittle, third-party integrations.
The architecture correctly maps its requirements to GitHub's evolving, dual-pronged AI strategy. It recognizes that "Copilot" is not a monolithic entity but a suite of tools designed for different purposes. For the synchronous, transactional task of analyzing content and returning structured data, the system uses the GitHub Models API. This REST-based interface is ideal for scripting within a GitHub Action, where a prompt is sent and a JSON response is expected.
For the asynchronous, stateful task of reviewing a pull request and suggesting improvements, the system invokes the Copilot Coding Agent. This is achieved by programmatically assigning the pull request to the @github-copilot user. This triggers an autonomous agent that operates in its own sandboxed, Actions-powered environment to perform its task, mirroring how a human collaborator would work. This architectural distinction is key to creating a robust system that aligns with GitHub's intended use cases and avoids the pitfalls of using undocumented or private APIs.
The complete loop is comprised of:
* GitHub Actions: The orchestrator, running the entire process on a schedule or on demand.
* GitHub REST API: The data source, providing programmatic access to stars, repository metadata, issues, and pull requests.1
* GitHub Models API: The analytical engine for classification and summarization.
* Copilot Coding Agent: The autonomous reviewer and refactorer for pull requests.
* GitHub Issues & Pull Requests: The primary human-computer interface for review, approval, and exception handling.9


Part II: The Manifest (repos.yml) - Schema and Governance




2.1. Full Schema Definition


The repos.yml file is the central nervous system of the curation repository. Its structure is strictly defined to ensure data consistency and to provide a clear contract for all automation scripts. A validation step within the CI pipeline will enforce this schema.
Field Name
	Data Type
	Required?
	Description
	Example
	feature_flags
	object
	Yes
	Container for global workflow settings that control automation behavior.
	

	feature_flags.ai_sort
	boolean
	Yes
	If true, the workflow will use Copilot to automatically classify categories and tags for new repositories.
	true
	feature_flags.ai_summarize_nondescript
	boolean
	Yes
	If true, the workflow will use Copilot to generate a summary for repositories with a poor or missing readme_quality.
	true
	feature_flags.batch_threshold
	integer
	Yes
	The number of new or changed repositories that must be detected to trigger a single, batched pull request.
	3
	feature_flags.auto_merge
	boolean
	Yes
	If true, pull requests with passing CI checks will be configured to merge automatically. Requires branch protection rules to be set.
	false
	repos
	array[object]
	Yes
	The list of all curated starred repositories.
	

	repos.repo
	string
	Yes
	The unique identifier for the repository in owner/name format. This is the primary key.
	user/rizzui
	repos.categories
	array[string]
	No
	A list of one or more functional buckets assigned to the repository.
	[ui-libraries]
	repos.tags
	array[string]
	No
	A list of descriptive tags, using prefixes for namespaces (e.g., lang:, framework:, feature:).
	[lang:typescript, framework:react]
	repos.framework
	string | null
	No
	The single, primary framework identified in the repository, if any. null if not applicable.
	react
	repos.readme_quality
	string
	No
	An AI-assessed evaluation of the repository's README file. Values: good, poor, missing.
	good
	repos.summary
	string
	No
	A concise, one-sentence summary of the repository's purpose, either generated by AI or provided manually.
	"A modern React UI library..."
	repos.last_synced_sha
	string
	Yes
	The full commit SHA of the repository's default branch the last time it was successfully processed. Used for caching.
	abcd1234...
	repos.starred_at
	string (ISO 8601)
	Yes
	The timestamp indicating when the user originally starred the repository.
	2025-07-14T10:00:00Z
	

2.2. Feature Flag Deep Dive


The feature_flags block provides high-level control over the workflow's most powerful and resource-intensive operations, allowing the user to tailor the automation to their needs without editing the workflow logic itself.
* ai_sort: This flag governs the core classification functionality. When set to true, the workflow will execute the AI analysis job, calling the GitHub Models API to determine categories and tags for new repositories. If set to false, this job is skipped. Instead, new repositories are added to the manifest with empty categories and tags fields, and a GitHub Issue is automatically created with the needs-manual-classification label, prompting the user for manual curation.
* ai_summarize_nondescript: This flag controls the documentation generation feature. When true, the workflow will analyze the readme_quality field. If the quality is assessed as poor or missing, a second call to the GitHub Models API is made to generate a concise summary based on the repository's description and language. This ensures that even poorly documented projects have a useful summary in the curated collection.
* batch_threshold: This integer value dictates the batching behavior. The workflow will count the number of new and updated repositories to be processed. If this count is greater than batch_threshold, all changes will be consolidated into a single pull request. This prevents "notification spam" from many individual PRs and is more efficient for API rate limit consumption.
* auto_merge: This is the master switch for enabling a fully "hands-off" workflow. When true, the final step of the workflow will attempt to enable the auto-merge setting on the created pull request. This is strictly contingent on the repository having correctly configured branch protection rules. If the rules are not met (e.g., a required status check is not defined), the auto-merge will fail, and the PR will require manual merging.7 When
false, all PRs will require manual user intervention to merge.


Part III: Core Workflow Implementation (.github/workflows/curate-stars.yml)


The heart of the system is a single, multi-job GitHub Actions workflow file. This file orchestrates every step of the process, from data fetching to AI analysis and repository generation.


3.1. Workflow Triggers and Permissions


To provide both consistent automation and manual control, the workflow is configured with multiple triggers.
   * Triggers (on:):
   * schedule: The workflow is set to run on a daily schedule (e.g., cron: '0 2 * * *') to automatically pick up any new stars from the previous day.
   * workflow_dispatch: This allows the user to manually trigger a run at any time from the "Actions" tab of the repository, which is useful for forcing an immediate sync after starring several repositories.
   * Permissions: To adhere to the principle of least privilege, the workflow explicitly defines the permissions required for the automatically generated GITHUB_TOKEN. This is a critical security practice to prevent the workflow from performing unintended actions.
   * contents: write: Necessary for the workflow to commit changes to repos.yml, add/remove submodules, and generate README.md files.
   * pull-requests: write: Required to create pull requests and assign reviewers (including @github-copilot).
   * issues: write: Required for the error-handling steps to create GitHub Issues when a job fails.


3.2. Job 1: Sync & Discover


This initial job is responsible for fetching the current state of the user's starred repositories and determining what, if any, work needs to be done.
   * Step 1: Checkout Repository: A standard actions/checkout@v4 step to get a copy of the curation repository.
   * Step 2: Fetch Starred Repositories: This step uses the GitHub CLI (gh) for its robust handling of authentication and API calls. The command gh api --paginate /user/starred is executed.
   * The --paginate flag automatically handles the traversal of paginated API responses, fetching all results without manual looping.13
   * A custom header Accept: application/vnd.github.v3.star+json is passed to ensure the starred_at timestamp is included in the response for each repository. This is a mandatory requirement for the API to return this specific data.1
   * The output is piped to a JSON file (e.g., stars.json).
   * Step 3: Identify New & Changed Repos: A script (e.g., a small Python or Node.js script) is executed. It performs the following logic:
   1. Loads the existing repos.yml manifest.
   2. Loads the stars.json file fetched in the previous step.
   3. Identifies newly starred repositories by finding entries in stars.json that are not present in repos.yml.
   4. For existing repositories, it makes a gh api /repos/{owner}/{repo} call to get the latest metadata, specifically the pushed_at timestamp or the default branch's head commit SHA. This is compared against the last_synced_sha in the manifest to detect if the repository has been updated since the last sync.
   5. The script outputs a list of repositories that require processing.
   * Step 4: Caching: The workflow utilizes actions/cache@v4. The cache key is generated from a hash of the repos.yml file: key: ${{ runner.os }}-stars-${{ hashFiles('repos.yml') }}. If the manifest has not changed since the last successful run, a cache hit occurs, and subsequent jobs in the workflow can be skipped, saving considerable runner time and resources.10


3.3. Job 2: AI-Powered Classification & Enrichment


This job is the intelligence core of the system. It runs conditionally, only if the "Sync & Discover" job identifies repositories needing processing.
   * Step 1: Setup Environment: This step installs the necessary tools for making HTTP requests and parsing JSON, such as Python with the requests and PyYAML libraries.
   * Step 2: Loop Through New Repos: A script iterates through the list of new and changed repositories identified in the previous job.
   * Step 3: Call GitHub Models API: For each repository, the script constructs and sends a POST request to the https://api.github.com/inference/chat/completions endpoint.
   * Authentication: The request is authenticated using the Authorization: Bearer ${{ secrets.GITHUB_TOKEN }} header.
   * Prompt Engineering: The success of the AI classification hinges on carefully engineered prompts that instruct the model to return structured, predictable JSON. This avoids the need for fragile string parsing of natural language responses.
Task
	Prompt
	Expected Output Format (JSON Schema)
	Classification
	Analyze the following README.md content for the repository {repo_name}. Based only on the provided text, determine the single most appropriate primary category from this list: [dev-tools, ui-libraries, data-science, ai-ml, infrastructure, security, learning, applications, other]. Also provide a list of relevant tags using these prefixes: lang: for language, framework: for framework, feature: for key features, platform: for platform compatibility. Identify a single primary framework if one is dominant. Finally, assess the README quality as good (detailed, with usage examples), poor (brief or lacking detail), or missing. Respond only with a valid JSON object matching this schema: {"properties": {"category": {"type": "string"}, "tags": {"type": "array", "items": {"type": "string"}}, "framework": {"type": ["string", "null"]}, "readme_quality": {"type": "string", "enum": ["good", "poor", "missing"]}}, "required": ["category", "tags", "framework", "readme_quality"]}. README Content: {readme_content}
	A valid JSON object adhering to the specified schema.
	Summarization
	The repository {repo_name} has a poor or missing README. Its description is: "{repo_description}" and its primary language is {repo_language}. Generate a concise, neutral, one-sentence summary (under 150 characters) describing the repository's main purpose. This summary will be used in a public catalog. Respond only with a valid JSON object matching this schema: {"properties": {"summary": {"type": "string"}}, "required": ["summary"]}.
	A valid JSON object containing the summary string.
	   * Step 4: Update Manifest File: The script parses the JSON response from the API. If the response is valid and conforms to the expected schema, the script updates the corresponding entry in the repos.yml file in the workflow's workspace.


3.4. Job 3: Repository Generation & Structuring


This job executes after the manifest has been successfully updated. It is responsible for translating the declarative state in repos.yml into a physical directory structure.
   * Step 1: Clean Workspace: To ensure idempotency and prevent orphaned files or submodule entries, this step performs a "nuke and pave" operation. It runs git rm -rf by-category/ by-tag/ by-framework/ and rm -f.gitmodules. This guarantees that the generated structure is always a fresh representation of the manifest.
   * Step 2: Parse Manifest: A script reads the final, updated repos.yml file.
   * Step 3: Generate Structure & Submodules: The script iterates through each repository entry in the manifest. For each category, tag, and framework associated with a repository, it performs the following actions:
   1. Creates the necessary directory path, e.g., mkdir -p by-category/dev-tools.
   2. Executes the git submodule add command: git submodule add --name {repo_owner}-{repo_name} https://github.com/{repo_owner}/{repo_name}.git by-category/dev-tools/{repo_name}. Using the --name flag provides a unique identifier in the .gitmodules file, which is crucial as the same repository will be added as a submodule in multiple locations (e.g., once under its category and multiple times under its tags).5 This approach is complex but directly fulfills the requirement of having the original repo accessible at multiple organizational paths.
   * Step 4: Generate READMEs: After all submodules have been added, a final script pass generates a README.md file in each parent directory (e.g., /by-tag/lang:go/README.md). This README will contain a Markdown-formatted list of all the submodules located within that directory, including their AI-generated summaries from the manifest.


Part IV: The Human-in-the-Loop: Managing PRs, Issues, and Errors


This system is designed to automate repetitive tasks, elevating the user's role to that of a reviewer and exception handler. The primary interface for this interaction is not a terminal or log file, but the familiar GitHub UI of Pull Requests and Issues.


4.1. Automated Pull Request Generation


Once the repository structure is generated, a new job creates a pull request to merge these changes into the main branch. This is handled by the robust and widely-used peter-evans/create-pull-request@v7 action.6
   * Configuration:
   * title: A descriptive title is generated, such as Chore: Update Star Curation for $(date +%Y-%m-%d).
   * body: The body provides context, indicating the number of new or updated repositories and pointing to the manifest diff for details.
   * commit-message: A conventional commit message is used, e.g., chore(curation): sync starred repositories.
   * branch: A unique branch name is created for each run, such as curation-bot/update-${{ github.run_id }}, to prevent branch name collisions.
   * token: The standard ${{ secrets.GITHUB_TOKEN }} is sufficient.


4.2. The Copilot Review & Improvement Loop


To fulfill the requirement of having Copilot review the changes, the workflow triggers the Copilot Coding Agent immediately after the PR is created.
   * Step 1: Assign Copilot to PR: A step runs if: steps.cpr.outputs.pull-request-number!= '' to ensure a PR was actually created. It then uses the GitHub CLI to programmatically assign the @github-copilot user to the new PR:
Bash
gh pr edit ${{ steps.cpr.outputs.pull-request-number }} --add-assignee "@github-copilot" --add-reviewer "@github-copilot"

   * Copilot's Role: This assignment acts as a prompt to the Copilot Coding Agent. The agent will:
      1. Activate and analyze the pull request's content.
      2. Focus on the generated README.md files, potentially suggesting improvements to formatting, clarity, or grammar.
      3. If it identifies areas for improvement, it will push new commits directly to the PR's branch.14
      * User Interaction: The user is not locked out of this process. They can add comments to the pull request, and the Coding Agent is designed to read these comments and attempt to address the feedback in subsequent commits, creating a collaborative loop between the user and the AI.


4.3. Robust Error Handling & Issue Creation


A core principle of this design is that no failure goes unnoticed. Every job includes a final step that executes conditionally on failure (if: failure()). This ensures that any unexpected error is captured and transformed into a trackable work item.
      * Action: This step uses the dacbd/create-issue-action@main action, which is well-suited for this purpose.9
      * Issue Content: The issue is created using the predefined template. It is dynamically populated with rich context from the failed workflow run, including:
      * The workflow name (${{ github.workflow }}).
      * A direct link to the failed run logs (https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}).
      * The name of the step that failed.
      * The full log output from the failed step, providing immediate context for debugging.
      * Labels: The issue is automatically labeled with triage and ai-failure, and can include more specific labels like needs-manual-classification or api-error depending on the nature of the failure. This creates a formal, visible "dead-letter queue" within GitHub, turning transient failures into persistent, actionable tasks.


Part V: Repository Setup and Maintenance




5.1. Initial Repository Configuration


To deploy this system, a user must perform a one-time setup of their repository.
      1. Create Repository Files:
      * Create the workflow file at .github/workflows/curate-stars.yml and paste in the complete workflow code.
      * Create the issue template at .github/ISSUE_TEMPLATE.md.
      * Create the root repos.yml file, containing only the feature_flags block with the desired initial settings.
      2. Configure Repository Settings:
      * Navigate to Settings > Actions > General.
      * Under "Workflow permissions," ensure that "Read and write permissions" are selected to grant the GITHUB_TOKEN the necessary scopes (contents: write, pull-requests: write, etc.).


5.2. Enabling Safe Auto-Merge


The auto_merge: true feature flag is a powerful tool, but it must be paired with strict repository governance to be safe. This is achieved through branch protection rules on the main branch. Auto-merge can only be enabled on pull requests that target a branch with such protections in place.7
The following rules must be configured for the main branch to allow the workflow to safely auto-merge pull requests.


Rule
	Configuration
	Rationale
	Require a pull request before merging
	Enabled.
	This is the fundamental rule that enforces the PR-based workflow. All changes must come through a pull request, which is the entry point for our entire automation loop.15
	Require status checks to pass before merging
	Enabled.
	This is the primary gate for auto-merge. The pull request cannot be merged until all required CI checks are green.16
	Required status checks
	Add the name of the CI sanity-check job from the workflow (e.g., ci-sanity-check).
	This specifically links the merge requirement to the successful validation of our manifest schema and file structure, preventing corrupted states from being merged.
	Require conversation resolution before merging
	Recommended.
	Prevents merging if there are active review comments or requested changes, ensuring that any feedback (from the user or Copilot) is addressed.
	Require linear history
	Optional.
	Enforces a cleaner, more readable commit history by requiring squash or rebase merges. This is a stylistic choice but is generally good practice for automated commits.17
	

Part VI: Complete Implementation Artifacts




6.1. Full Workflow YAML (.github/workflows/curate-stars.yml)




YAML




# This workflow orchestrates the entire GitHub-native star curation process.
# It fetches starred repos, uses GitHub Models API for classification,
# generates a structured repository with submodules, and creates a PR.
name: 'Curate Starred Repos'

on:
 workflow_dispatch:
 schedule:
   - cron: '0 3 * * *' # Run daily at 3 AM UTC

permissions:
 contents: write
 pull-requests: write
 issues: write

jobs:
 discover-and-classify:
   name: 'Sync, Classify & Generate'
   runs-on: ubuntu-latest
   outputs:
     new_changes: ${{ steps.commit.outputs.new_changes }}
     branch_name: ${{ steps.vars.outputs.branch_name }}

   steps:
     - name: 'Checkout Repository'
       uses: actions/checkout@v4
       with:
         # Fetch all history for accurate last-synced-sha comparison
         fetch-depth: 0

     - name: 'Set up Python'
       uses: actions/setup-python@v5
       with:
         python-version: '3.11'

     - name: 'Install Python Dependencies'
       run: pip install requests pyyaml

     - name: 'Set up Unique Branch Name'
       id: vars
       run: echo "branch_name=curation-bot/update-${{ github.run_id }}" >> $GITHUB_OUTPUT

     - name: 'Sync Stars and Classify with Copilot'
       id: classify
       env:
         GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
       run: |
         # This would be a Python script that encapsulates the logic from Parts 3.2 and 3.3
         # 1. Fetches all starred repos using `gh api --paginate /user/starred`
         # 2. Loads repos.yml
         # 3. Diffs to find new/updated repos
         # 4. For each new repo, calls the GitHub Models API for classification and summarization
         # 5. Updates the repos.yml file in the workspace
         # For the purpose of this blueprint, we'll simulate this with a placeholder script.
         python./.github/scripts/sync_and_classify.py
      
     - name: 'Generate Repository Structure'
       id: generate
       run: |
         # This would be a Python script that encapsulates the logic from Part 3.4
         # 1. Reads the updated repos.yml
         # 2. Cleans the workspace (git rm -rf by-*/.gitmodules)
         # 3. Creates directories and adds git submodules for each repo based on its metadata
         # 4. Generates README.md files in each category/tag/framework directory
         python./.github/scripts/generate_structure.py

     - name: 'Check for Changes'
       id: diff
       run: |
         git status
         if git diff --quiet; then
           echo "No changes to commit."
           echo "new_changes=false" >> $GITHUB_OUTPUT
         else
           echo "Changes detected."
           echo "new_changes=true" >> $GITHUB_OUTPUT
         fi

     - name: 'Commit Changes'
       id: commit
       if: steps.diff.outputs.new_changes == 'true'
       run: |
         git config --global user.name 'github-actions[bot]'
         git config --global user.email 'github-actions[bot]@users.noreply.github.com'
         git add.
         git commit -m "chore(curation): Sync starred repositories and update structure"
         git push --force origin HEAD:${{ steps.vars.outputs.branch_name }}

 create-pr:
   name: 'Create Pull Request'
   needs: discover-and-classify
   if: needs.discover-and-classify.outputs.new_changes == 'true'
   runs-on: ubuntu-latest

   steps:
     - name: 'Create Pull Request'
       id: cpr
       uses: peter-evans/create-pull-request@v7
       with:
         token: ${{ secrets.GITHUB_TOKEN }}
         commit-message: 'chore(curation): Automated star curation update'
         title: 'Chore: Update Star Curation for ${{ env.CURRENT_DATE }}'
         body: |
           Automated update of starred repositories.
           - This PR was generated by the `curate-stars` workflow.
           - It includes updates to the `repos.yml` manifest and the corresponding directory structure.
           - Assigned to @github-copilot for automated review and documentation improvements.
          branch: ${{ needs.discover-and-classify.outputs.branch_name }}
         base: main
         reviewers: 'github-copilot'
         assignees: 'github-copilot'
       env:
         CURRENT_DATE: $(date -u +"%Y-%m-%d")

     - name: 'Enable Auto-Merge if Flag is Set'
       if: success() && fromJson(needs.discover-and-classify.outputs.feature_flags).auto_merge == true
       env:
         GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
         PR_URL: ${{ steps.cpr.outputs.pull-request-url }}
       run: gh pr merge --auto --squash "$PR_URL"

 report-failure:
   name: 'Report Workflow Failure'
   if: failure() && (needs.discover-and-classify.result == 'failure' |

| needs.create-pr.result == 'failure')
   runs-on: ubuntu-latest
   steps:
     - name: 'Create Failure Issue'
       uses: dacbd/create-issue-action@main
       with:
         token: ${{ secrets.GITHUB_TOKEN }}
         title: '🚩 Workflow Failure: Star Curation Failed'
         body: |
           The `curate-stars` workflow failed.

           **Run Details:**
           - **Workflow:** `${{ github.workflow }}`
           - **Run ID:** `${{ github.run_id }}`
           - **Link to Logs:** `https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}`

           **Action Required:**
           - [ ] Review the workflow logs to diagnose the failure.
           - [ ] Manually resolve the issue (e.g., fix a script, correct the manifest).
           - [ ] Close this issue once the root cause is resolved and merged.
         labels: 'ai-failure, triage, bug'



6.2. Issue and PR Templates




Issue Template (.github/ISSUE_TEMPLATE.md)




🚩 Manual Review Needed


Repo: user/repo
Action: Classification | README Summary | Other
Workflow Run: [Link to failed run](${{ env.RUN_URL }})


What Happened:


      * [ ] Classification failed (log below)
      * [ ] README summary generation failed (log below)
      * [ ] Repo is private/nonexistent/archived
      * [ ] Submodule generation failed
      * [ ] Other API or script error
Logs:
${{ env.LOG_DETAILS }}






**Next Steps:**
- [ ] Manually edit `repos.yml` to add tags/category/summary.
- [ ] Review the failing script or API call.
- [ ] Create a PR with the fix and reference this issue.
- [ ] Close this issue once the fix is merged.

**Labels:** `needs-manual-classification`, `needs-manual-summary`, `ai-failure`, `triage`



Pull Request Template (.github/PULL_REQUEST_TEMPLATE.md)




Summary of Changes


This pull request contains automated updates from the curate-stars workflow. It includes changes to the repos.yml manifest and regenerates the repository structure to match.


Type of Change


      * [ ] New Repo(s): Added new starred repositories to the collection.
      * [ ] Repo Update(s): Updated metadata for existing repositories.
      * [ ] Docs: Regenerated README.md files.
      * [ ] Chore: Routine synchronization.


Review Checklist


      * [ ] The repos.yml diff looks correct.
      * [ ] New submodules have been added correctly.
      * [ ] CI checks are passing.
      * [ ] Review suggestions from @github-copilot have been addressed.
________________
This PR was generated automatically. If auto_merge is enabled and checks pass, it will be merged without manual intervention.


6.3. Sample Generated README (/by-category/dev-tools/README.md)




Category: Development Tools


This directory contains curated repositories classified under the "Development Tools" category.
________________


Repositories


Repository
	Summary
	cli-tool
	Cross-platform CLI tool for managing project configurations and environment variables, written in Rust. (Generated by Copilot)
	tokei
	A fast and accurate code counter that displays statistics about your code, supporting over 150 languages.
	git-summary
	A shell script that summarizes the status of all cloned git repositories found within a directory.
	________________
This document is auto-generated by the star curation workflow. Do not edit directly.


Conclusions and Recommendations


This technical blueprint details a robust, scalable, and entirely self-contained system for personal github-stars curation. By strictly adhering to a GitHub-native philosophy, the design ensures long-term stability and maintainability, leveraging official and well-supported platform features like GitHub Actions, the GitHub Models API, and the Copilot Coding Agent.
Key Architectural Strengths:
      * Idempotency and Auditability: The manifest-driven approach, where repos.yml is the single source of truth, makes the entire process idempotent and fully auditable through git history.
      * Intelligent Automation: The system correctly distinguishes between and utilizes GitHub's two primary AI interaction models: the transactional Models API for synchronous analysis and the autonomous Copilot Coding Agent for asynchronous review tasks. This alignment with GitHub's intended product use is critical for reliability.
      * Transparent Failure Handling: By converting every failure into a detailed, trackable GitHub Issue, the system avoids silent failures and provides a clear, actionable path for manual intervention. The user's workflow is simplified to reviewing PRs for successes and Issues for failures.
      * Zero External Dependencies: The entire system lives and breathes within the GitHub ecosystem, eliminating the fragility associated with third-party services, external scripts, or undocumented APIs.
Recommendations for Implementation:
      1. Phased Rollout: It is advisable to implement the system in phases. Begin with the auto_merge feature flag set to false. This allows for manual verification of the generated pull requests, building confidence in the automation before enabling a fully hands-off workflow.
      2. Prompt Iteration: The quality of AI-driven classification is directly proportional to the quality of the prompts. The provided prompts are a strong starting point, but they should be considered living documents. The user should refine them over time based on the quality of the results.
      3. Submodule Management Awareness: The use of git submodules is a powerful but complex feature. The "nuke and pave" strategy outlined is the most robust method for ensuring consistency but requires careful implementation. Any manual changes to the .gitmodules file should be avoided, as they will be overwritten by the workflow.
      4. Monitor Copilot and Actions Usage: The Copilot Coding Agent and GitHub Actions both consume resources that may be subject to billing or usage quotas depending on the user's plan. It is important to monitor this usage, especially during the initial setup and processing of a large backlog of starred repositories.
By following this blueprint, a developer can construct a sophisticated, modern, and "anti-bloat" personal knowledge management system that is not only powerful but also a showcase of what is possible within the integrated GitHub platform of 2025 and beyond.
Works cited
      1. REST API endpoints for starring - GitHub Docs, accessed July 14, 2025, https://docs.github.com/en/rest/activity/starring
      2. That Github's API makes it so easy to fetch a user's starred repo history, accessed July 14, 2025, https://dannguyen.github.io/til/posts/github-starred-timestamps
      3. GitHub Actions Cache - A Complete Guide with Examples - CICube, accessed July 14, 2025, https://cicube.io/blog/github-actions-cache/
      4. Optimizing GitHub Actions Performance: Enhance Workflows with Caching, accessed July 14, 2025, https://dev.to/ken_mwaura1/optimizing-github-actions-performance-enhance-workflows-with-caching-4hla
      5. Checkout submodules · Actions · GitHub Marketplace, accessed July 14, 2025, https://github.com/marketplace/actions/checkout-submodules
      6. Create Pull Request · Actions · GitHub Marketplace · GitHub, accessed July 14, 2025, https://github.com/marketplace/actions/create-pull-request
      7. Automatically merging a pull request - GitHub Checkout - YouTube, accessed July 14, 2025, https://www.youtube.com/watch?v=G_TP-2cRypU
      8. Managing auto-merge for pull requests in your repository - GitHub Docs, accessed July 14, 2025, https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/managing-auto-merge-for-pull-requests-in-your-repository
      9. Create Github Issue · Actions · GitHub Marketplace · GitHub, accessed July 14, 2025, https://github.com/marketplace/actions/create-github-issue
      10. Dependency caching reference - GitHub Docs, accessed July 14, 2025, https://docs.github.com/en/actions/reference/dependency-caching-reference
      11. GitHub REST API documentation - GitHub Docs, accessed July 14, 2025, https://docs.github.com/en/rest
      12. Creating a pull request - GitHub Docs, accessed July 14, 2025, https://docs.github.com/articles/creating-a-pull-request
      13. Traversing with Pagination | GitHub API - LFE Documentation, accessed July 14, 2025, http://docs2.lfe.io/guides/traversing-with-pagination/
      14. Assigning and completing issues with coding agent in GitHub Copilot, accessed July 14, 2025, https://github.blog/ai-and-ml/github-copilot/assigning-and-completing-issues-with-coding-agent-in-github-copilot/
      15. Managing a branch protection rule - GitHub Docs, accessed July 14, 2025, https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/managing-a-branch-protection-rule
      16. About protected branches - GitHub Docs, accessed July 14, 2025, https://docs.github.com/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/about-protected-branches
      17. Available rules for rulesets - GitHub Docs, accessed July 14, 2025, https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-rulesets/available-rules-for-rulesets
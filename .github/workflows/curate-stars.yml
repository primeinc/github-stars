---
name: 'Curate Starred Repos'

on:
  schedule:
    - cron: '0 3 * * *'  # Daily at 3 AM UTC
  workflow_dispatch:
    inputs:
      test_limit:
        description: 'Limit total repos for testing (0 = no limit)'
        type: number
        default: 20

permissions:
  contents: write
  pull-requests: write
  issues: write

env:
  TEST_LIMIT: ${{ github.event.inputs.test_limit || '20' }}

concurrency:
  group: curate-stars-${{ github.ref }}
  cancel-in-progress: false

jobs:
  sync-and-classify:
    runs-on: ubuntu-latest
    outputs:
      manifest_updated: ${{ steps.diff.outputs.changed }}
      total_new_repos: ${{ steps.diff.outputs.total_new }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.STARS_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Validate existing manifest schema
        uses: cardinalby/schema-validator-action@v3
        with:
          schema: 'schemas/repos-schema.json'
          file: 'repos.yml'
          mode: 'lax'

      - name: Read fetched stars data
        id: read_stars
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.STARS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = '.github-stars/data/fetched-stars-graphql.json';

            if (!fs.existsSync(path)) {
              core.setFailed('Fetched stars data not found. Please run fetch-stars workflow first.');
              return;
            }

            let starsData;
            try {
              starsData = JSON.parse(fs.readFileSync(path, 'utf8'));
            } catch (error) {
              core.setFailed(`Failed to parse stars data: ${error.message}`);
              return;
            }
            
            // Validate data structure
            if (!Array.isArray(starsData)) {
              core.setFailed('Invalid stars data format: expected array');
              return;
            }
            
            console.log(`Found ${starsData.length} starred repositories`);

            // Apply test limit if specified
            const testLimit = parseInt(process.env.TEST_LIMIT || '0');
            if (testLimit > 0 && starsData.length > testLimit) {
              console.log(`Limiting to first ${testLimit} repos for testing`);
              starsData = starsData.slice(0, testLimit);
            }

            return starsData;

      - name: Read current manifest
        id: read_manifest
        uses: mikefarah/yq@v4.46.1
        with:
          cmd: yq eval '.' repos.yml -o=json

      - name: Update manifest with new repositories
        id: diff
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.STARS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const starsData = ${{ steps.read_stars.outputs.result }};
            let manifestData;
            try {
              manifestData = JSON.parse(`${{ steps.read_manifest.outputs.result }}`) || { repositories: [] };
            } catch (error) {
              core.setFailed(`Failed to parse manifest data: ${error.message}`);
              return;
            }
            
            // Ensure required objects exist
            if (!manifestData.repositories) {
              manifestData.repositories = [];
            }
            if (!manifestData.manifest_metadata) {
              manifestData.manifest_metadata = {};
            }
            
            // Set correct github user from context
            manifestData.manifest_metadata.github_user = context.repo.owner;

            console.log(`Starred repos: ${starsData.length}`);
            console.log(`Manifest repos: ${manifestData.repositories.length}`);

            // Extract repo names from current manifest (with null safety)
            const existingRepos = new Set(manifestData.repositories.filter(r => r && r.repo).map(r => r.repo));

            // Find new repos that aren't in the manifest (with null safety)
            const newRepos = starsData.filter(star => star && star.repo && !existingRepos.has(star.repo));

            // Find removed repos (in manifest but not in stars) (with null safety)
            // CRITICAL: Only check for removals if we're not using test limit to avoid data loss
            const testLimit = parseInt(process.env.TEST_LIMIT || '0');
            const currentStarRepos = new Set(starsData.filter(s => s && s.repo).map(s => s.repo));
            const removedRepos = testLimit > 0 ? [] : manifestData.repositories.filter(r => r && r.repo && !currentStarRepos.has(r.repo));

            console.log(`New repos to add: ${newRepos.length}`);
            console.log(`Repos to remove: ${removedRepos.length}`);
            
            if (testLimit > 0) {
              console.log(`⚠️  TEST MODE: Repository removals disabled to prevent data loss`);
            }

            const hasChanges = newRepos.length > 0 || removedRepos.length > 0;

            // Log summary
            if (newRepos.length > 0) {
              console.log('New repositories to add:');
              newRepos.slice(0, 5).forEach(repo => console.log(`  - ${repo.repo}`));
              if (newRepos.length > 5) {
                console.log(`  ... and ${newRepos.length - 5} more`);
              }
            }

            // Update manifest if there are changes
            if (hasChanges) {
              // Remove deleted repositories (only if not in test mode)
              if (testLimit === 0) {
                manifestData.repositories = manifestData.repositories.filter(r => 
                  r && r.repo && currentStarRepos.has(r.repo)
                );
              }

              // Add new repositories (only new ones, never duplicates) with data validation and cleaning
              const cleanDescription = (desc) => {
                if (!desc || desc.trim() === '') return 'No description provided';
                
                // Clean markdown headers and formatting
                let cleaned = desc
                  .replace(/^#+\s*/, '')                    // Remove leading # headers
                  .replace(/([a-z])([A-Z])/g, '$1 $2')     // Add spaces between camelCase
                  .replace(/([A-Z]{2,})([a-z])/g, '$1 $2') // Fix acronyms like MCPAn -> MCP An
                  .replace(/\s+/g, ' ')                     // Normalize whitespace
                  .trim();
                
                // Truncate if too long
                if (cleaned.length > 200) {
                  cleaned = cleaned.substring(0, 197) + '...';
                }
                
                return cleaned;
              };
              
              const newRepoEntries = newRepos.map(repo => ({
                repo: repo.repo,
                categories: ["unclassified"],
                tags: [],
                framework: null,
                summary: cleanDescription(repo.description),
                last_synced_sha: repo.last_commit_sha || '',
                starred_at: repo.starred_at || new Date().toISOString(),
                readme_quality: "missing",
                archived: Boolean(repo.archived),
                fork: Boolean(repo.fork),
                needs_review: true
              }));

              manifestData.repositories.push(...newRepoEntries);

              // Update metadata
              manifestData.manifest_metadata.last_updated = new Date().toISOString();
              manifestData.manifest_metadata.total_repos = manifestData.repositories.length;

              // Write updated manifest as JSON first, then convert with yq
              try {
                fs.writeFileSync('manifest-temp.json', JSON.stringify(manifestData, null, 2));
              } catch (error) {
                core.setFailed(`Failed to write manifest file: ${error.message}`);
                return;
              }

              console.log(`Updated manifest: +${newRepos.length} repos, -${removedRepos.length} repos`);
            }

            core.setOutput('changed', hasChanges);
            core.setOutput('total_new', newRepos.length);

      - name: Convert manifest back to YAML
        if: steps.diff.outputs.changed == 'true'
        uses: mikefarah/yq@v4.46.1
        with:
          cmd: yq eval '.' manifest-temp.json -o=yaml > repos.yml

      - name: Clean up temp files
        if: always()
        run: rm -f manifest-temp.json

      - name: Validate updated manifest
        if: steps.diff.outputs.changed == 'true'
        uses: cardinalby/schema-validator-action@v3
        with:
          schema: 'schemas/repos-schema.json'
          file: 'repos.yml'
          mode: 'lax'

      - name: Create Pull Request with changes
        if: steps.diff.outputs.changed == 'true'
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.STARS_TOKEN || secrets.GITHUB_TOKEN }}
          commit-message: |
            Update repos.yml with new starred repositories

            - Added ${{ steps.diff.outputs.total_new }} new repositories
            - All new repos marked as 'unclassified' for review
            - Updated manifest metadata timestamp

            🤖 Generated with [Claude Code](https://claude.ai/code)

            Co-Authored-By: Claude <noreply@anthropic.com>
          title: "🌟 Sync starred repositories (${{ steps.diff.outputs.total_new }} new)"
          body: |
            ## Summary

            - ✅ Added **${{ steps.diff.outputs.total_new }}** new starred repositories to the manifest
            - ✅ All new repositories are initially marked as `unclassified` and `needs_review: true`
            - ✅ Updated manifest metadata with current timestamp
            - ✅ Schema validation passed

            ## New Repositories Added

            ${{ steps.diff.outputs.total_new > 0 && 'The following repositories were added:' || 'No new repositories to add.' }}

            ## Test Plan

            - [x] Schema validation passes
            - [x] Manifest structure is valid
            - [ ] Manual review of new repositories for proper categorization
            - [ ] Run AI classification workflow after merge (if enabled)

            ## Next Steps

            1. Review the new repositories and update their categories/tags
            2. Enable AI classification for automatic categorization
            3. Generate repository structure with submodules

            🤖 Generated with [Claude Code](https://claude.ai/code)
          branch: sync-starred-repos-${{ github.run_number }}
          delete-branch: true

  classify-repositories:
    needs: sync-and-classify
    runs-on: ubuntu-latest
    if: needs.sync-and-classify.outputs.manifest_updated == 'true'
    permissions:
      contents: write
      models: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.STARS_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Read updated manifest
        id: read_updated_manifest
        uses: mikefarah/yq@v4.46.1
        with:
          cmd: yq eval '.' repos.yml -o=json

      - name: Read original stars data
        id: read_stars_for_ai
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = '.github-stars/data/fetched-stars-graphql.json';
            
            if (!fs.existsSync(path)) {
              console.log('No stars data available for AI classification');
              return [];
            }
            
            const starsData = JSON.parse(fs.readFileSync(path, 'utf8'));
            return starsData;

      - name: Prepare repositories for AI classification
        id: prep_repos
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let manifestData;
            try {
              manifestData = JSON.parse(`${{ steps.read_updated_manifest.outputs.result }}`);
            } catch (error) {
              core.setFailed(`Failed to parse updated manifest: ${error.message}`);
              return;
            }

            // Find repositories that need review
            const unclassifiedRepos = manifestData.repositories.filter(repo => 
              repo.needs_review === true && 
              repo.categories.includes('unclassified')
            );

            console.log(`Found ${unclassifiedRepos.length} repositories needing AI classification`);

            if (unclassifiedRepos.length === 0) {
              console.log('No repositories need classification');
              core.setOutput('has_repos', 'false');
              return;
            }
            
            console.log('🤖 Starting dual-AI classification process:');
            console.log('  1. Primary AI will classify repositories');
            console.log('  2. Validator AI will review classifications');
            console.log('  3. Only approved classifications will be applied');

            // Get original stars data for language info
            const starsData = ${{ steps.read_stars_for_ai.outputs.result }};

            // Prepare repo data for AI (get language from original stars data)
            const repoData = unclassifiedRepos.map(repo => {
              const starRepo = starsData ? starsData.find(s => s.repo === repo.repo) : null;
              return {
                repo: repo.repo,
                summary: repo.summary,
                language: starRepo ? starRepo.language : null,
                starred_at: repo.starred_at
              };
            });

            // Write repo data for AI
            fs.writeFileSync('repos-to-classify.json', JSON.stringify(repoData, null, 2));
            core.setOutput('has_repos', 'true');
            core.setOutput('repo_count', unclassifiedRepos.length);

      - name: Create system prompt file
        if: steps.prep_repos.outputs.has_repos == 'true'
        run: |
          cat > classification-system-prompt.txt << 'EOF'
          You are a repository classification expert. Analyze GitHub repositories and classify them accurately.
          
          Available categories: dev-tools, ui-libraries, frameworks, databases, productivity, learning, documentation, automation, testing, deployment, monitoring, security, ai-ml, data-science, web-dev, mobile-dev, desktop-dev, game-dev, embedded, networking, system-admin, cloud, containers, apis, unclassified
          
          Available frameworks: react, vue, angular, svelte, nextjs, nuxtjs, express, fastapi, django, flask, rails, laravel, spring
          
          Language tags should use namespace format: lang:js, lang:ts, lang:python, lang:rust, lang:go
          
          Return a JSON array with this exact structure for each repository:
          {
            "repo": "owner/name",
            "categories": ["category1", "category2"],
            "tags": ["tag1", "tag2", "lang:language"],
            "framework": "framework-name-or-null"
          }
          
          Rules:
          - Each repo should have 1-3 relevant categories (never just "unclassified" unless truly unclear)
          - Include language tags based on the programming language
          - Framework should be null if not a framework-specific project
          - Be conservative with framework assignment
          - Tags should be lowercase, hyphenated
          EOF

      - name: AI classify repositories  
        id: ai_classify
        if: steps.prep_repos.outputs.has_repos == 'true'
        uses: actions/ai-inference@v1
        with:
          model: 'openai/gpt-4o'
          max-tokens: '2000'
          system-prompt-file: 'classification-system-prompt.txt'
          prompt-file: 'repos-to-classify.json'

      - name: Create validation prompt
        if: steps.prep_repos.outputs.has_repos == 'true'
        run: |
          cat > validation-prompt.txt << 'EOF'
          Review these AI classifications and validate them. Check for:
          1. Categories are appropriate and from the allowed list
          2. Framework assignments are conservative and accurate
          3. Language tags match the actual programming language
          4. Tags are properly formatted (lowercase, hyphenated)
          5. No obvious misclassifications
          
          Return ONLY "APPROVED" if all classifications look correct, or "REJECTED: [specific issues]" if there are problems.
          
          Original repo data:
          EOF
          cat repos-to-classify.json >> validation-prompt.txt
          echo "" >> validation-prompt.txt
          echo "AI Classifications:" >> validation-prompt.txt
          echo '${{ steps.ai_classify.outputs.response }}' >> validation-prompt.txt

      - name: Validate AI classifications
        id: ai_validate
        if: steps.prep_repos.outputs.has_repos == 'true'
        uses: actions/ai-inference@v1
        with:
          model: 'openai/gpt-4o'
          max-tokens: '500'
          system-prompt: 'You are a classification validator. Be strict about accuracy and only approve classifications that are clearly correct.'
          prompt-file: 'validation-prompt.txt'

      - name: Apply AI classification results
        id: apply_classification
        if: steps.prep_repos.outputs.has_repos == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Check validation result first
            const validationResult = `${{ steps.ai_validate.outputs.response }}`.trim();
            console.log('Validation Result:', validationResult);
            
            if (!validationResult.startsWith('APPROVED')) {
              core.setFailed(`AI classifications rejected by validator: ${validationResult}`);
              return;
            }
            
            console.log('✅ AI classifications approved by validator');
            
            // Read the AI response
            const aiResponse = `${{ steps.ai_classify.outputs.response }}`;
            console.log('AI Response:', aiResponse);
            
            let classifications;
            try {
              classifications = JSON.parse(aiResponse);
            } catch (error) {
              console.error('Failed to parse AI response as JSON:', error);
              core.setFailed(`AI returned invalid JSON: ${error.message}`);
              return;
            }
            
            if (!Array.isArray(classifications)) {
              core.setFailed('AI response is not an array');
              return;
            }

            // Read current manifest
            let manifestData;
            try {
              manifestData = JSON.parse(`${{ steps.read_updated_manifest.outputs.result }}`);
            } catch (error) {
              core.setFailed(`Failed to parse manifest: ${error.message}`);
              return;
            }

            // Apply classifications
            let classifiedCount = 0;
            classifications.forEach(classification => {
              const repoIndex = manifestData.repositories.findIndex(r => r.repo === classification.repo);
              if (repoIndex !== -1) {
                manifestData.repositories[repoIndex].categories = classification.categories;
                manifestData.repositories[repoIndex].tags = classification.tags || [];
                manifestData.repositories[repoIndex].framework = classification.framework;
                manifestData.repositories[repoIndex].needs_review = false;
                classifiedCount++;
                
                console.log(`Classified ${classification.repo}: ${classification.categories.join(', ')}`);
              }
            });

            // Update metadata
            manifestData.manifest_metadata.last_updated = new Date().toISOString();

            // Write updated manifest
            try {
              fs.writeFileSync('manifest-classified.json', JSON.stringify(manifestData, null, 2));
              console.log(`Successfully classified ${classifiedCount} repositories`);
            } catch (error) {
              core.setFailed(`Failed to write classified manifest: ${error.message}`);
              return;
            }

            core.setOutput('classified_count', classifiedCount);

      - name: Create validation failure issue
        if: failure() && steps.ai_validate.outputs.response != ''
        uses: actions/github-script@v7
        with:
          script: |
            const validationResult = `${{ steps.ai_validate.outputs.response }}`;
            const repoCount = `${{ steps.prep_repos.outputs.repo_count }}`;
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `🤖 AI Classification Validation Failed (${repoCount} repos)`,
              body: `## AI Classification Validation Failure
              
              **Validation Result:**
              \`\`\`
              ${validationResult}
              \`\`\`
              
              **Original Classifications:**
              \`\`\`json
              ${{ steps.ai_classify.outputs.response }}
              \`\`\`
              
              **Repositories Affected:**
              ${repoCount} repositories need manual classification.
              
              **Next Steps:**
              1. Review the validation feedback
              2. Manually classify the repositories
              3. Update the classification prompts if needed
              
              cc: @${context.repo.owner}`,
              labels: ['ai-classification', 'validation-failed', 'needs-review']
            });

      - name: Convert classified manifest to YAML
        if: steps.apply_classification.outputs.classified_count > 0
        uses: mikefarah/yq@v4.46.1
        with:
          cmd: yq eval '.' manifest-classified.json -o=yaml > repos.yml

      - name: Clean up temp files
        if: always()
        run: rm -f manifest-classified.json repos-to-classify.json classification-system-prompt.txt validation-prompt.txt

      - name: Validate classified manifest
        if: steps.apply_classification.outputs.classified_count > 0
        uses: cardinalby/schema-validator-action@v3
        with:
          schema: 'schemas/repos-schema.json'
          file: 'repos.yml'
          mode: 'lax'

      - name: Commit AI classification results
        if: steps.apply_classification.outputs.classified_count > 0
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add repos.yml
          git commit -m "🤖 AI classify ${{ steps.apply_classification.outputs.classified_count }} repositories

          - Automatically categorized repositories using AI classification
          - Updated framework detection and tagging
          - Marked classified repos as no longer needing review

          🤖 Generated with [Claude Code](https://claude.ai/code)

          Co-Authored-By: Claude <noreply@anthropic.com>"
          git push

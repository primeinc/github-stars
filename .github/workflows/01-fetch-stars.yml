name: '01-Fetch GitHub Stars'

on:
  workflow_dispatch:
  schedule:
    - cron: '0 3 * * *'  # Daily at 3 AM UTC

permissions:
  contents: write

# Ensure only one instance runs at a time
concurrency:
  group: fetch-stars
  cancel-in-progress: false

jobs:
  fetch-stars:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    # Run on all branches for validation, but only commit from main
    outputs:
      total_repos: ${{ steps.fetch-stars.outputs.total_repos }}
      archived_count: ${{ steps.fetch-stars.outputs.archived_count }}
      fork_count: ${{ steps.fetch-stars.outputs.fork_count }}
      no_description_count: ${{ steps.fetch-stars.outputs.no_description_count }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        
      - name: Setup environment with branch isolation
        id: setup
        run: |
          # Use branch-specific data directory to prevent conflicts
          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            DATA_DIR=".github-stars/data"
          else
            DATA_DIR="/tmp/github-stars-data-${{ github.run_id }}"
          fi
          mkdir -p "$DATA_DIR"
          echo "DATA_DIR=$DATA_DIR" >> $GITHUB_ENV
          echo "data_dir=$DATA_DIR" >> $GITHUB_OUTPUT
          echo "Using data directory: $DATA_DIR"
        
      - name: Fetch starred repositories
        uses: actions/github-script@v8
        id: fetch-stars
        with:
          github-token: ${{ secrets.STARS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            
            // Read the GraphQL query from file
            const queryPath = 'queries/stars-query.graphql';
            if (!fs.existsSync(queryPath)) {
              throw new Error(`GraphQL query file not found: ${queryPath}`);
            }
            const STARS_QUERY = fs.readFileSync(queryPath, 'utf8');
            
            // Configuration
            const MAX_RETRIES = 3;
            const OUTPUT_FILE = `${process.env.DATA_DIR}/fetched-stars-graphql.json`;
            
            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
            
            let hasNextPage = true;
            let cursor = null;
            let allRepos = [];
            let pageCount = 0;
            let retryCount = 0;
            
            while (hasNextPage) {
              pageCount++;
              core.info(`Fetching page ${pageCount}...`);
              
              try {
                const result = await github.graphql(STARS_QUERY, cursor ? { cursor } : {});
                const repos = result.viewer.starredRepositories;
                retryCount = 0;
                
                const pageRepos = repos.edges.map(edge => ({
                  repo: edge.node.nameWithOwner,
                  description: edge.node.description || '',
                  language: edge.node.primaryLanguage?.name || null,
                  topics: edge.node.repositoryTopics.nodes.map(n => n.topic.name),
                  archived: edge.node.isArchived,
                  fork: edge.node.isFork,
                  private: edge.node.isPrivate,
                  stargazers_count: edge.node.stargazerCount,
                  forks_count: edge.node.forkCount,
                  updated_at: edge.node.updatedAt,
                  pushed_at: edge.node.pushedAt,
                  disk_usage: edge.node.diskUsage,
                  owner_avatar: edge.node.owner.avatarUrl,
                  html_url: edge.node.url,
                  default_branch: edge.node.defaultBranchRef?.name || 'main',
                  last_commit_sha: edge.node.defaultBranchRef?.target?.oid || null,
                  user_starred_at: edge.starredAt,
                  homepage_url: edge.node.homepageUrl,
                  is_mirror: edge.node.isMirror,
                  mirror_url: edge.node.mirrorUrl,
                  license: edge.node.licenseInfo?.spdxId || null,
                  latest_release: edge.node.latestRelease ? {
                    tag: edge.node.latestRelease.tagName,
                    published_at: edge.node.latestRelease.publishedAt
                  } : null
                }));
                
                const publicRepos = pageRepos.filter(r => !r.private);
                allRepos = allRepos.concat(publicRepos);
                
                hasNextPage = repos.pageInfo.hasNextPage;
                cursor = repos.pageInfo.endCursor;
                
                core.info(`  Found ${publicRepos.length} public repos (total: ${allRepos.length})`);
                
                if (hasNextPage) await sleep(500);
                
              } catch (error) {
                if (error.message?.includes('rate limit')) {
                  core.warning('Rate limit hit. Saving partial results.');
                  core.setOutput('partial_fetch', 'true');
                  core.setOutput('rate_limited', 'true');
                  break;
                }
                
                if (retryCount < MAX_RETRIES) {
                  retryCount++;
                  const waitTime = Math.pow(2, retryCount);
                  core.warning(`Retrying in ${waitTime}s (${retryCount}/${MAX_RETRIES})...`);
                  await sleep(waitTime * 1000);
                  pageCount--;
                  continue;
                }
                
                if (allRepos.length > 0) {
                  core.warning('Error occurred, saving partial results...');
                  break;
                }
                throw error;
              }
            }
            
            core.info(`\nTotal: ${allRepos.length} repositories`);
            
            const outputDir = path.dirname(OUTPUT_FILE);
            if (!fs.existsSync(outputDir)) {
              fs.mkdirSync(outputDir, { recursive: true });
            }
            fs.writeFileSync(OUTPUT_FILE, JSON.stringify(allRepos, null, 2));
            
            const archived = allRepos.filter(r => r.archived).length;
            const forks = allRepos.filter(r => r.fork).length;
            const noDesc = allRepos.filter(r => !r.description).length;
            
            core.info(`Archived: ${archived}, Forks: ${forks}, No description: ${noDesc}`);
            
            core.setOutput('total_repos', allRepos.length);
            core.setOutput('archived_count', archived);
            core.setOutput('fork_count', forks);
            core.setOutput('no_description_count', noDesc);
            core.setOutput('partial_fetch', hasNextPage ? 'true' : 'false');

      - name: Upload results
        if: success() && steps.fetch-stars.outputs.total_repos != '0'
        uses: actions/upload-artifact@v6
        with:
          name: fetched-stars-${{ github.run_id }}
          path: ${{ env.DATA_DIR }}/fetched-stars-graphql.json
          retention-days: 30
          
      - name: Create job summary
        run: |
          echo "# GitHub Stars Fetch" >> $GITHUB_STEP_SUMMARY
          echo "- **Total**: ${{ steps.fetch-stars.outputs.total_repos }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Archived**: ${{ steps.fetch-stars.outputs.archived_count }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Forks**: ${{ steps.fetch-stars.outputs.fork_count }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
          if [ "$CURRENT_BRANCH" != "main" ]; then
            echo "⚠️ **Running in validation mode** (branch: $CURRENT_BRANCH)" >> $GITHUB_STEP_SUMMARY
            echo "Results will NOT be committed. Artifacts only." >> $GITHUB_STEP_SUMMARY
          else
            echo "✅ **Running in production mode** (branch: main)" >> $GITHUB_STEP_SUMMARY
            echo "Results will be committed to main branch." >> $GITHUB_STEP_SUMMARY
          fi
          
      - name: Commit results
        run: |
          CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
          
          if [ "$CURRENT_BRANCH" != "main" ]; then
            echo "=========================================="
            echo "⚠️  VALIDATION MODE (branch: $CURRENT_BRANCH)"
            echo "=========================================="
            echo "✅ Workflow executed successfully"
            echo "✅ Results validated and saved to artifacts"
            echo "❌ Skipping commit (not on main branch)"
            echo ""
            echo "This prevents data corruption while allowing PR validation."
            echo "Results artifact: fetched-stars-${{ github.run_id }}"
            echo "=========================================="
            exit 0
          fi
          
          echo "=========================================="
          echo "✅ PRODUCTION MODE (branch: main)"
          echo "=========================================="
          echo "Committing results to main branch..."
          
          git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          if [ ! -f "$DATA_DIR/fetched-stars-graphql.json" ]; then
            echo "No results to commit"
            exit 0
          fi
          
          # Ensure main data directory exists
          mkdir -p .github-stars/data
          cp "$DATA_DIR/fetched-stars-graphql.json" .github-stars/data/
          
          git add .github-stars/data/fetched-stars-graphql.json
          
          if git diff --staged --quiet; then
            echo "No changes"
          else
            git commit -m "chore: update starred repositories [skip ci]"
            bash scripts/safe-git-push.sh main
            echo "✅ Changes committed and pushed"
          fi
          echo "=========================================="

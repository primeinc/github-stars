name: Classify Repos

on:
  workflow_dispatch:
    inputs:
      batch_limit:
        description: 'Repos per batch'
        type: number
        default: 15
  workflow_run:
    workflows: ["Sync Starred Repos"]
    types:
      - completed

permissions:
  contents: write
  issues: write
  models: read
  actions: write

env:
  BATCH_LIMIT: ${{ inputs.batch_limit || 15 }}

jobs:
  classify:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success'
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: main

      - run: |
          for i in 1 2 3; do
            git pull origin main && break || sleep 5
          done

      - name: Setup
        run: |
          mkdir -p .github-stars/data
          wget -qO ./yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          chmod +x ./yq

      - name: Prepare repos
        id: prep
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            if (!fs.existsSync('repos.yml')) {
              core.setOutput('has_repos', 'false');
              return;
            }
            
            const yaml = fs.readFileSync('repos.yml', 'utf8');
            const json = execSync('./yq eval -o=json -', { input: yaml, encoding: 'utf8', maxBuffer: 50*1024*1024 });
            const data = JSON.parse(json);

            const unclassified = data.repositories.filter(r => 
              r.categories.includes('unclassified') && 
              (r.needs_review || !r.ai_classification?.classified_at)
            );

            const limit = parseInt(process.env.BATCH_LIMIT) || 15;
            const batch = unclassified.sort((a,b) => new Date(a.user_starred_at) - new Date(b.user_starred_at)).slice(0, Math.min(limit, 100));
            
            console.log(`Processing ${batch.length} of ${unclassified.length} unclassified repos`);
            
            if (batch.length === 0) {
              core.setOutput('has_repos', 'false');
              return;
            }

            const repoData = batch.map(r => ({
              repo: r.repo,
              summary: r.summary,
              language: r.github_metadata?.language || null,
              topics: r.github_metadata?.topics || [],
              stargazers_count: r.github_metadata?.stargazers_count || 0
            }));

            const systemPrompt = `Classify GitHub repos. Output ONLY a JSON array.

            CATEGORIES: dev-tools, ui-libraries, frameworks, databases, productivity, learning, documentation, automation, testing, deployment, monitoring, security, ai-ml, data-science, web-dev, mobile-dev, desktop-dev, game-dev, embedded, networking, system-admin, cloud, containers, apis, cli-tools, devops, infrastructure

            FRAMEWORKS: react, vue, angular, svelte, nextjs, nuxtjs, express, fastapi, django, flask, rails, laravel, spring

            LANGUAGE TAGS: lang:js, lang:ts, lang:python, lang:rust, lang:go, lang:java, lang:kotlin, lang:swift, lang:ruby, lang:cpp, lang:c, lang:csharp, lang:php

            RULES:
            - 2-4 categories per repo
            - 3-6 descriptive tags (include lang:X if language provided)
            - framework must be from list above OR null
            - Output ONLY valid JSON array, no markdown
            - First char must be [, last must be ]

            EXAMPLE: [{"repo":"microsoft/vscode","categories":["dev-tools"],"tags":["code-editor","lang:ts"],"framework":null}]`;

            fs.writeFileSync('.github-stars/data/system-prompt.txt', systemPrompt);
            fs.writeFileSync('.github-stars/data/user-prompt.txt', 
              'Classify these repositories:\n\n' + JSON.stringify(repoData, null, 2));

            core.setOutput('has_repos', 'true');
            core.setOutput('repo_count', batch.length);

      - name: AI classify
        id: ai
        if: steps.prep.outputs.has_repos == 'true'
        uses: actions/ai-inference@v2
        with:
          model: openai/gpt-4o
          max-tokens: 3000
          system-prompt-file: .github-stars/data/system-prompt.txt
          prompt-file: .github-stars/data/user-prompt.txt

      - name: Apply
        id: apply
        if: steps.prep.outputs.has_repos == 'true'
        uses: actions/github-script@v8
        env:
          AI_RESPONSE_FILE: ${{ steps.ai.outputs.response-file }}
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            // Read from file to avoid template literal escaping issues
            const responseFile = process.env.AI_RESPONSE_FILE;
            let result = fs.readFileSync(responseFile, 'utf8').trim()
              .replace(/^```json\s*/i, '').replace(/\s*```$/i, '');
            
            // Try to fix common JSON issues
            // Remove trailing commas before ] or }
            result = result.replace(/,(\s*[\]}])/g, '$1');
            // Fix unescaped newlines in strings
            result = result.replace(/:\s*"([^"]*)\n([^"]*)"/g, (m, a, b) => `: "${a}\\n${b}"`);
            
            let classifications;
            try {
              classifications = JSON.parse(result);
            } catch (e) {
              // Try to extract valid JSON array if wrapped in other content
              const match = result.match(/\[[\s\S]*\]/);
              if (match) {
                try {
                  classifications = JSON.parse(match[0]);
                } catch (e2) {
                  console.log('JSON parse failed, will retry workflow');
                  core.setOutput('retry', 'true');
                  core.setOutput('count', 0);
                  return;
                }
              } else {
                console.log('No JSON array found, will retry workflow');
                core.setOutput('retry', 'true');
                core.setOutput('count', 0);
                return;
              }
            }
            
            if (!Array.isArray(classifications)) {
              console.log('Not an array, will retry workflow');
              core.setOutput('retry', 'true');
              core.setOutput('count', 0);
              return;
            }

            const yaml = fs.readFileSync('repos.yml', 'utf8');
            const json = execSync('./yq eval -o=json -', { input: yaml, encoding: 'utf8', maxBuffer: 50*1024*1024 });
            const data = JSON.parse(json);

            let count = 0;
            const tagPattern = /^([a-z]+:)?[a-z0-9][a-z0-9-]*$/;

            for (const c of classifications) {
              const idx = data.repositories.findIndex(r => r.repo === c.repo);
              if (idx !== -1) {
                // Sanitize categories (basic check)
                const safeCategories = (c.categories || []).filter(cat => /^[a-z][a-z0-9-]*$/.test(cat)).slice(0, 5);
                
                // Sanitize tags: lowercase, replace space with dash, filter by pattern
                const safeTags = (c.tags || [])
                  .map(t => t.toLowerCase().replace(/[^a-z0-9-:]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, ''))
                  .filter(t => tagPattern.test(t))
                  .slice(0, 20);

                data.repositories[idx].categories = safeCategories.length > 0 ? safeCategories : ["unclassified"];
                data.repositories[idx].tags = safeTags;
                data.repositories[idx].framework = c.framework;
                data.repositories[idx].needs_review = false;
                data.repositories[idx].ai_classification = {
                  model: "gpt-4o",
                  classified_at: new Date().toISOString(),
                  prompt_version: "v2"
                };
                count++;
              }
            }

            data.manifest_metadata.manifest_updated_at = new Date().toISOString();
            fs.writeFileSync('.github-stars/data/manifest.json', JSON.stringify(data, null, 2));
            core.setOutput('count', count);

      - name: Convert to YAML
        if: steps.apply.outputs.count > 0
        run: ./yq eval '.' .github-stars/data/manifest.json -o=yaml > repos.yml

      - name: Cleanup
        if: always()
        run: rm -f .github-stars/data/*.json .github-stars/data/*.txt

      - name: Validate
        if: steps.apply.outputs.count > 0
        uses: cardinalby/schema-validator-action@v3
        with:
          schema: schemas/repos-schema.json
          file: repos.yml
          mode: lax

      - name: Commit
        if: steps.apply.outputs.count > 0
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add repos.yml
          git commit -m "AI classify ${{ steps.apply.outputs.count }} repos [skip ci]"
          git push

      - name: Check remaining
        id: remaining
        if: steps.apply.outputs.count > 0
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            const yaml = fs.readFileSync('repos.yml', 'utf8');
            const json = execSync('./yq eval -o=json -', { input: yaml, encoding: 'utf8', maxBuffer: 50*1024*1024 });
            const data = JSON.parse(json);
            const remaining = data.repositories.filter(r => 
              r.categories.includes('unclassified') && (r.needs_review || !r.ai_classification?.classified_at)
            ).length;
            core.setOutput('count', remaining);
            core.setOutput('has_more', remaining > 0);

      - name: Trigger next
        if: steps.remaining.outputs.has_more == 'true' || steps.apply.outputs.retry == 'true'
        uses: actions/github-script@v8
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: '03-classify-repos.yml',
              ref: 'main',
              inputs: { batch_limit: String(process.env.BATCH_LIMIT) }
            });

      - run: |
          echo "## Summary" >> $GITHUB_STEP_SUMMARY
          echo "Classified: ${{ steps.apply.outputs.count || 0 }}" >> $GITHUB_STEP_SUMMARY
          echo "Remaining: ${{ steps.remaining.outputs.count || 'N/A' }}" >> $GITHUB_STEP_SUMMARY

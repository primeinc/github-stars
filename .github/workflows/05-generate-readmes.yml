name: '05-Generate READMEs'

on:
  workflow_dispatch:
  push:
    paths:
      - 'repos.yml'
    branches:
      - main
  workflow_run:
    workflows: ["02-Sync Starred Repos", "03-Classify Repos"]
    types:
      - completed

permissions:
  contents: write

jobs:
  generate:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' || github.event_name == 'push' || github.event.workflow_run.conclusion == 'success'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: main

      - name: Setup yq
        run: |
          wget -qO ./yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          chmod +x ./yq

      - name: Generate Content
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            const path = require('path');

            // 1. Load Data
            if (!fs.existsSync('repos.yml')) {
              console.log('No repos.yml found');
              return;
            }
            const yaml = fs.readFileSync('repos.yml', 'utf8');
            const json = execSync('./yq eval -o=json -', { input: yaml, encoding: 'utf8', maxBuffer: 50*1024*1024 });
            const data = JSON.parse(json);
            const repos = data.repositories || [];
            
            // 2. Prepare Directories
            ['categories', 'tags'].forEach(dir => {
              if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
            });

            // 3. Helper Functions
            const slugify = (text) => text.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)+/g, '');
            const escapeMd = (text) => (text || '').replace(/([*_`\[\]])/g, '\$1');
            const formatDate = (iso) => iso ? new Date(iso).toISOString().split('T')[0] : 'N/A';
            
            const renderRepoRow = (repo) => {
              const stars = repo.github_metadata?.stargazers_count || 0;
              const lang = repo.github_metadata?.language || '';
              const pushed = formatDate(repo.github_metadata?.repo_pushed_at);
              const desc = (repo.summary || 'No description').replace(/\n/g, ' ');
              const name = repo.repo;
              const url = repo.github_metadata?.html_url || `https://github.com/${name}`;
              
              let badges = [];
              if (lang) badges.push(`\`${lang}\``);
              if (stars > 1000) badges.push(`‚òÖ ${Math.round(stars/100)/10}k`);
              else if (stars > 0) badges.push(`‚òÖ ${stars}`);
              
              return `| [${name}](${url}) | ${escapeMd(desc)} | ${badges.join(' ')} | ${pushed} |`;
            };

            const renderTableHeader = () => `| Repository | Description | Metadata | Last Pushed |\n|---|---|---|---|`;

            // 4. Generate Category Pages
            const categories = {};
            repos.forEach(r => {
              (r.categories || []).forEach(c => {
                if (!categories[c]) categories[c] = [];
                categories[c].push(r);
              });
            });

            Object.entries(categories).forEach(([cat, items]) => {
              const sorted = items.sort((a,b) => new Date(b.user_starred_at) - new Date(a.user_starred_at));
              const content = `# ${cat.charAt(0).toUpperCase() + cat.slice(1)}\n\n` +
                `*${sorted.length} repositories*\n\n` +
                `[‚Üê Back to Index](../README.md)\n\n` +
                renderTableHeader() + '\n' +
                sorted.map(renderRepoRow).join('\n') + '\n\n' +
                `*Generated by [GitHub Stars Curation](https://github.com/primeinc/github-stars)*`;
              
              fs.writeFileSync(`categories/${cat}.md`, content);
            });

            // 5. Generate Tag Pages
            const tags = {};
            repos.forEach(r => {
              (r.tags || []).forEach(t => {
                if (t.startsWith('lang:')) return; // Skip language tags in tag cloud
                if (!tags[t]) tags[t] = [];
                tags[t].push(r);
              });
            });

            Object.entries(tags).forEach(([tag, items]) => {
              if (items.length < 2) return; // Skip sparse tags
              const sorted = items.sort((a,b) => new Date(b.user_starred_at) - new Date(a.user_starred_at));
              const content = `# Tag: ${tag}\n\n` +
                `*${sorted.length} repositories*\n\n` +
                `[‚Üê Back to Index](../README.md)\n\n` +
                renderTableHeader() + '\n' +
                sorted.map(renderRepoRow).join('\n');
              
              fs.writeFileSync(`tags/${tag}.md`, content);
            });

            // 6. Generate Main Index (README.md)
            const stats = {
              total: repos.length,
              categories: Object.keys(categories).length,
              tags: Object.keys(tags).length
            };

            const sortedCats = Object.keys(categories).sort();
            const topTags = Object.entries(tags)
              .sort((a,b) => b[1].length - a[1].length)
              .slice(0, 30)
              .map(([t, i]) => `[${t}](tags/${t}.md) (${i.length})`);

            let indexContent = `# Awesome Starred Repositories\n\n` +
              `> A curated list of **${stats.total}** repositories, automatically classified and organized.\n\n` +
              `Last updated: ${new Date().toISOString().split('T')[0]}\n\n` +
              `## üìÇ Categories\n\n`;

            // Group categories by letter for better readability
            let currentLetter = '';
            sortedCats.forEach(cat => {
              const letter = cat.charAt(0).toUpperCase();
              if (letter !== currentLetter) {
                indexContent += `\n### ${letter}\n`;
                currentLetter = letter;
              }
              const count = categories[cat].length;
              indexContent += `- [${cat}](categories/${cat}.md) *(${count})*\n`;
            });

            indexContent += `\n## üè∑Ô∏è Popular Tags\n\n` + topTags.join(' ‚Ä¢ ') + `\n\n`;
            
            // Add Recent Stars Section
            const recent = repos
              .sort((a,b) => new Date(b.user_starred_at) - new Date(a.user_starred_at))
              .slice(0, 10);
            
            indexContent += `## ‚≠ê Recently Starred\n\n` +
              renderTableHeader() + '\n' +
              recent.map(renderRepoRow).join('\n');

            indexContent += `\n\n---\n*Powered by [GitHub Stars Curation System](https://github.com/primeinc/github-stars)*`;

            fs.writeFileSync('README.md', indexContent);
            console.log('README generation complete.');

      - name: Commit changes
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add README.md categories/ tags/
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "docs: generate READMEs [skip ci]"
            for i in 1 2 3 4 5; do
              git pull --rebase --autostash origin main
              git push && break || sleep 10
            done
          fi

---
name: '02-Sync Starred Repos'

on:
  workflow_dispatch:
  workflow_run:
    workflows: ["01-Fetch GitHub Stars"]
    types:
      - completed

permissions:
  contents: write
  issues: write

# Ensure only one instance runs at a time
concurrency:
  group: sync-stars
  cancel-in-progress: false

jobs:
  sync:
    runs-on: ubuntu-latest
    timeout-minutes: 15  # Prevent hung workflows
    # Run on all branches for validation, but only commit from main
    if: github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Check if repos.yml exists
        id: check_repos
        run: |
          if [ -f "repos.yml" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Validate existing manifest
        if: steps.check_repos.outputs.exists == 'true'
        uses: cardinalby/schema-validator-action@v3
        with:
          schema: 'schemas/repos-schema.json'
          file: 'repos.yml'
          mode: 'lax'

      - name: Setup environment
        run: mkdir -p .github-stars/data

      - name: Update manifest
        id: diff
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            // In validation mode (non-main branches), artifact is not committed
            // Download it from the triggering workflow run instead
            const currentBranch = context.ref.replace('refs/heads/', '');
            let starsDataPath = '.github-stars/data/fetched-stars-graphql.json';
            
            if (currentBranch !== 'main') {
              console.log('⚠️  Non-main branch: checking for upstream artifact...');
              // Artifact should be downloaded separately in validation mode
              // For now, check if file exists, otherwise provide helpful error
              if (!fs.existsSync(starsDataPath)) {
                core.setFailed('Validation mode: fetched-stars artifact not found. Download artifact from triggering workflow run first.');
                process.exit(1);
              }
            } else if (!fs.existsSync(starsDataPath)) {
              core.setFailed('Run fetch-stars workflow first (file not found in committed workspace).');
              process.exit(1);  // Actually exit
            }

            const starsData = JSON.parse(fs.readFileSync(starsDataPath, 'utf8'));
            if (!Array.isArray(starsData)) {
              core.setFailed('Invalid stars data format');
              process.exit(1);  // Actually exit
            }
            
            console.log(`Found ${starsData.length} starred repositories`);
            
            if (fs.existsSync('repos.yml')) {
              yamlContent = fs.readFileSync('repos.yml', 'utf8');
            } else {
              yamlContent = fs.readFileSync('.github-stars/repos-template.yml', 'utf8');
            }
            
            // Increase buffer to 50MB to handle large manifests
            // yq (mikefarah) is pre-installed on ubuntu-latest runners since 2023
            const manifestJson = execSync('yq eval -o=json -', { 
              input: yamlContent, 
              encoding: 'utf8',
              maxBuffer: 50 * 1024 * 1024 
            });
            const manifestData = JSON.parse(manifestJson) || { repositories: [] };
            
            if (!manifestData.repositories) manifestData.repositories = [];
            if (!manifestData.manifest_metadata) manifestData.manifest_metadata = {};
            manifestData.manifest_metadata.github_user = context.repo.owner;

            const existingRepos = new Set(manifestData.repositories.filter(r => r?.repo).map(r => r.repo));
            const newRepos = starsData.filter(s => s?.repo && !existingRepos.has(s.repo));
            const currentStarRepos = new Set(starsData.filter(s => s?.repo).map(s => s.repo));
            const removedRepos = manifestData.repositories.filter(r => r?.repo && !currentStarRepos.has(r.repo));

            console.log(`New: ${newRepos.length}, Removed: ${removedRepos.length}`);

            if (newRepos.length > 0 || removedRepos.length > 0) {
              manifestData.repositories = manifestData.repositories.filter(r => r?.repo && currentStarRepos.has(r.repo));

              const cleanDescription = (desc) => {
                if (!desc?.trim()) return 'No description provided';
                let cleaned = desc
                  .replace(/^#+\s*/, '')
                  .replace(/([a-z])([A-Z])/g, '$1 $2')
                  .replace(/\s+/g, ' ')
                  .trim();
                return cleaned.length > 200 ? cleaned.substring(0, 197) + '...' : cleaned;
              };
              
              const newEntries = newRepos.map(repo => ({
                repo: repo.repo,
                categories: ["unclassified"],
                tags: [],
                summary: cleanDescription(repo.description),
                last_synced_sha: repo.last_commit_sha || '0'.repeat(40),
                user_starred_at: repo.user_starred_at || new Date().toISOString(),
                readme_quality: "missing",
                needs_review: true,
                ...(repo.archived && { archived: true }),
                ...(repo.fork && { fork: true }),
                github_metadata: {
                  language: repo.language || null,
                  topics: repo.topics || [],
                  stargazers_count: repo.stargazers_count || 0,
                  forks_count: repo.forks_count || 0,
                  disk_usage: repo.disk_usage || null,
                  owner_avatar: repo.owner_avatar || null,
                  homepage_url: repo.homepage_url || null,
                  license: repo.license || null,
                  repo_pushed_at: repo.pushed_at || null,
                  repo_updated_at: repo.updated_at || null,
                  html_url: repo.html_url || null,
                  default_branch: repo.default_branch || null,
                  latest_release: repo.latest_release || null,
                  is_mirror: repo.is_mirror || false,
                  mirror_url: repo.mirror_url || null
                }
              }));

              manifestData.repositories.push(...newEntries);
              manifestData.manifest_metadata.manifest_updated_at = new Date().toISOString();
              manifestData.manifest_metadata.total_repos = manifestData.repositories.length;

              fs.writeFileSync('.github-stars/data/manifest.json', JSON.stringify(manifestData, null, 2));
            }
            
            // Sync metadata for existing repos
            let updatedCount = 0;
            const repoMap = new Map(starsData.map(s => [s.repo, s]));
            for (const repo of manifestData.repositories) {
              const fresh = repoMap.get(repo.repo);
              if (fresh) {
                let changed = false;
                
                // Update user_starred_at if significantly different
                if (fresh.user_starred_at && fresh.user_starred_at !== repo.user_starred_at) {
                    repo.user_starred_at = fresh.user_starred_at;
                    changed = true;
                }

                // Update GitHub metadata
                if (repo.last_synced_sha !== fresh.last_commit_sha && fresh.last_commit_sha) {
                    repo.last_synced_sha = fresh.last_commit_sha;
                    changed = true;
                }
                
                if (fresh.updated_at && (!repo.github_metadata || repo.github_metadata.repo_updated_at !== fresh.updated_at)) {
                    if (!repo.github_metadata) repo.github_metadata = {};
                    repo.github_metadata.repo_updated_at = fresh.updated_at;
                    repo.github_metadata.repo_pushed_at = fresh.pushed_at;
                    repo.github_metadata.stargazers_count = fresh.stargazers_count;
                    repo.github_metadata.forks_count = fresh.forks_count;
                    repo.github_metadata.disk_usage = fresh.disk_usage;
                    repo.github_metadata.owner_avatar = fresh.owner_avatar;
                    repo.github_metadata.language = fresh.language;
                    repo.github_metadata.topics = fresh.topics;
                    repo.github_metadata.license = fresh.license;
                    changed = true;
                }
                
                if (changed) updatedCount++;
              }
            }
            
            if (updatedCount > 0) {
               console.log(`Updated metadata for ${updatedCount} existing repositories`);
               fs.writeFileSync('.github-stars/data/manifest.json', JSON.stringify(manifestData, null, 2));
               core.setOutput('changed', 'true');
            }

            core.setOutput('changed', newRepos.length > 0 || removedRepos.length > 0 || updatedCount > 0);
            core.setOutput('total_new', newRepos.length);

      - name: Convert to YAML
        if: steps.diff.outputs.changed == 'true'
        run: yq eval '.' .github-stars/data/manifest.json -o=yaml > repos.yml

      - name: Cleanup
        if: always()
        run: rm -f .github-stars/data/manifest.json

      - name: Validate manifest
        if: steps.diff.outputs.changed == 'true'
        uses: cardinalby/schema-validator-action@v3
        with:
          schema: 'schemas/repos-schema.json'
          file: 'repos.yml'
          mode: 'lax'

      - name: Commit changes
        if: steps.diff.outputs.changed == 'true'
        run: |
          CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
          
          if [ "$CURRENT_BRANCH" != "main" ]; then
            echo "=========================================="
            echo "⚠️  VALIDATION MODE (branch: $CURRENT_BRANCH)"
            echo "=========================================="
            echo "✅ Workflow executed successfully"
            echo "✅ Changes validated (would add ${{ steps.diff.outputs.total_new }} repos)"
            echo "❌ Skipping commit (not on main branch)"
            echo ""
            echo "This prevents data corruption while allowing PR validation."
            echo "=========================================="
            exit 0
          fi
          
          echo "=========================================="
          echo "✅ PRODUCTION MODE (branch: main)"
          echo "=========================================="
          echo "Committing ${{ steps.diff.outputs.total_new }} new repositories to main branch..."
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add repos.yml
          git commit -m "Sync ${{ steps.diff.outputs.total_new }} new starred repositories [skip ci]"
          bash scripts/safe-git-push.sh main
          echo "✅ Changes committed and pushed"
          echo "=========================================="

---
name: 'Curate Starred Repos'

on:
  workflow_dispatch:
    inputs:
      skip_validation:
        description: 'Skip AI validation step (cost savings)'
        type: boolean
        default: false
      bulk_process_limit:
        description: 'Process existing unclassified repos (0 = only new repos marked for review)'
        type: number
        default: 0
  workflow_run:
    workflows: ["Sync Starred Repos"]
    types:
      - completed

permissions:
  contents: write
  pull-requests: write
  issues: write
  models: read

concurrency:
  group: curate-stars-${{ github.ref }}
  cancel-in-progress: false

jobs:
  classify:
    runs-on: ubuntu-latest
    # Only run if manually triggered or if the triggering workflow succeeded
    if: github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success'

    steps:
      - name: Checkout repository  
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.STARS_TOKEN || secrets.GITHUB_TOKEN }}
          fetch-depth: 0
          ref: main

      - name: Pull latest changes with retry
        run: |
          echo "Ensuring we have the latest changes from workflow 02..."
          # Try to pull up to 3 times with a 5-second delay
          for i in 1 2 3; do
            if git pull origin main; then
              echo "âœ… Successfully pulled latest changes"
              break
            else
              echo "âš ï¸  Pull attempt $i failed, waiting 5 seconds..."
              sleep 5
            fi
          done
          
          # Verify repos.yml exists
          if [ -f "repos.yml" ]; then
            echo "âœ… repos.yml found"
            echo "File size: $(ls -lh repos.yml | awk '{print $5}')"
          else
            echo "âŒ ERROR: repos.yml not found after pulling latest changes"
            echo "Current directory contents:"
            ls -la
            exit 1
          fi
          
      - name: Setup environment  
        run: |
          mkdir -p .github-stars/data
          # Download yq locally
          wget -qO ./yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          chmod +x ./yq

      - name: AI classify repositories (consolidated)
        id: ai_classify_consolidated
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            // Check if repos.yml exists
            if (!fs.existsSync('repos.yml')) {
              console.log('repos.yml not found. Nothing to classify.');
              core.setOutput('classified_count', 0);
              return;
            }
            
            // Read YAML and convert to JSON using yq directly in memory
            const yamlContent = fs.readFileSync('repos.yml', 'utf8');
            const manifestJson = execSync('./yq eval -o=json -', { input: yamlContent, encoding: 'utf8' });
            const manifestData = JSON.parse(manifestJson);

            // Find repositories that have never been AI classified
            const bulkProcessLimit = parseInt('${{ github.event.inputs.bulk_process_limit }}' || '0');
            
            let reposToClassify;
            if (bulkProcessLimit > 0) {
              // Bulk processing mode: process up to X unclassified repos regardless of needs_review
              console.log(`ðŸ“¦ BULK PROCESSING MODE: Will process up to ${bulkProcessLimit} unclassified repos`);
              
              const unclassifiedRepos = manifestData.repositories.filter(repo => {
                return !repo.ai_classification || !repo.ai_classification.timestamp;
              });
              
              // Take first X unclassified repos
              reposToClassify = unclassifiedRepos.slice(0, bulkProcessLimit);
            } else {
              // Normal mode: only process repos marked for review
              reposToClassify = manifestData.repositories.filter(repo => {
                // Never been AI classified if ai_classification is missing or timestamp is null
                const neverClassified = !repo.ai_classification || !repo.ai_classification.timestamp;
                
                // Must be explicitly marked for review (throttling mechanism)
                const markedForReview = repo.needs_review === true;
                
                // Only classify if BOTH conditions are met
                return neverClassified && markedForReview;
              });
            }

            // Log breakdown for debugging
            const totalRepos = manifestData.repositories.length;
            const alreadyClassified = manifestData.repositories.filter(r => r.ai_classification && r.ai_classification.timestamp).length;
            const needsReviewCount = manifestData.repositories.filter(r => r.needs_review === true).length;
            const unclassifiedTotal = manifestData.repositories.filter(r => !r.ai_classification || !r.ai_classification.timestamp).length;
            
            console.log(`ðŸ“Š Repository breakdown:`);
            console.log(`  Total repos: ${totalRepos}`);
            console.log(`  Already AI classified: ${alreadyClassified}`);
            console.log(`  Never classified: ${unclassifiedTotal}`);
            console.log(`  Marked needs_review: ${needsReviewCount}`);
            console.log(`  Selected for processing: ${reposToClassify.length}`);
            
            if (bulkProcessLimit > 0) {
              console.log(`ðŸ“¦ BULK MODE: Processing ${reposToClassify.length} of ${unclassifiedTotal} unclassified repos`);
            } else {
              console.log(`ðŸŽ¯ NORMAL MODE: Processing ${reposToClassify.length} repos marked for review`);
            }

            if (reposToClassify.length === 0) {
              console.log('No repositories need classification');
              core.setOutput('classified_count', 0);
              return;
            }
            
            console.log('ðŸ¤– Starting dual-AI classification process:');
            console.log('  1. Primary AI will classify repositories');
            console.log('  2. Validator AI will review classifications');
            console.log('  3. Only approved classifications will be applied');

            // Get original stars data for language info
            const starsDataPath = '.github-stars/data/fetched-stars-graphql.json';
            if (!fs.existsSync(starsDataPath)) {
              core.setFailed('Fetched stars data not found. Please run fetch-stars workflow first.');
              return;
            }
            const starsData = JSON.parse(fs.readFileSync(starsDataPath, 'utf8'));

            // Prepare repo data for AI (get language from original stars data)
            const repoData = reposToClassify.map(repo => {
              const starRepo = starsData ? starsData.find(s => s.repo === repo.repo) : null;
              return {
                repo: repo.repo,
                summary: repo.summary,
                language: starRepo ? starRepo.language : null,
                starred_at: repo.starred_at
              };
            });

            console.log(`Found ${repoData.length} repositories to classify`);

            // Create system prompt
            const systemPrompt = `Classify GitHub repositories thoughtfully. Output ONLY a JSON array.
            
            SUGGESTED CATEGORIES (use these or create more specific ones):
            dev-tools, ui-libraries, frameworks, databases, productivity, learning, documentation, automation, testing, deployment, monitoring, security, ai-ml, data-science, web-dev, mobile-dev, desktop-dev, game-dev, embedded, networking, system-admin, cloud, containers, apis, cli-tools, devops, infrastructure, analytics, visualization, education, media, graphics, audio, video, iot, blockchain, crypto, finance, health, science, math, algorithms, compilers, languages, operating-systems, virtualization, backup, storage, messaging, search, cms, e-commerce, social, communication
            
            COMMON FRAMEWORKS (use if applicable):
            react, vue, angular, svelte, nextjs, nuxtjs, express, fastapi, django, flask, rails, laravel, spring
            
            LANGUAGE TAGS (use these exact formats when language is known):
            lang:js, lang:ts, lang:python, lang:rust, lang:go, lang:csharp, lang:php, lang:dart, lang:lua, lang:gdscript, lang:java, lang:kotlin, lang:swift, lang:ruby, lang:cpp, lang:c
            
            GUIDELINES:
            - Use 2-4 most relevant categories (be generous, repos often fit multiple categories)
            - Add 3-6 descriptive tags that capture the essence of the repo
            - Create new categories if existing ones don't fit well
            - Only set framework if the repo is specifically built with/for that framework
            - Include language tag only when provided in input data
            - Be creative and specific with tags (e.g., "infinite-canvas", "local-first", "markdown-editor")
            - Think about how someone might search for this repo
            
            STRICT RULES:
            1. framework: Must be EXACTLY one of the allowed frameworks OR null (not "null" string)
            2. categories: Array of 1-3 strings from ALLOWED CATEGORIES only
            3. tags: Include lang:X tag ONLY if language is provided in input data
            4. If input language is null/empty: DO NOT add any lang: tag
            5. CRITICAL: Output ONLY the JSON array. First character must be [, last character must be ]
            6. DO NOT include any text, markdown formatting, backticks, or explanations
            7. DO NOT say "Here is the classification" or similar phrases
            8. START YOUR RESPONSE WITH [ AND END WITH ]`;

            // Create classification prompt
            const classificationPrompt = `Please classify the following repositories according to the system prompt instructions:

            ${JSON.stringify(repoData, null, 2)}`;

            // Call primary AI for classification
            console.log('ðŸ¤– Calling primary AI for classification...');
            const classificationResponse = await github.request('POST /models/openai/gpt-4o/inferences', {
              input: {
                messages: [
                  { role: 'system', content: systemPrompt },
                  { role: 'user', content: classificationPrompt }
                ],
                max_tokens: 2000
              }
            });

            let aiClassificationResult = classificationResponse.data.choices[0].message.content.trim();
            
            // Strip any markdown formatting if AI didn't follow instructions
            aiClassificationResult = aiClassificationResult.replace(/^```json\s*/i, '').replace(/\s*```$/i, '').trim();
            
            console.log('AI Classification Result:', aiClassificationResult);

            let finalClassifications;
            const skipValidation = '${{ github.event.inputs.skip_validation }}' === 'true';

            if (skipValidation) {
              console.log('âš ï¸ Validation skipped - using original AI classifications');
              finalClassifications = aiClassificationResult;
            } else {
              // Create validation prompt
              const validationPrompt = `RESPOND WITH ONE OF:
              1. IF VALID: Output the CORRECTED JSON array (fixing any minor issues)
              2. IF INVALID: Output "REJECTED: [specific issue]"
              
              START YOUR RESPONSE WITH EITHER [ (for JSON) OR "REJECTED:" (for rejection)
              
              Validation criteria:
              - Categories should be relevant and descriptive (can use suggested ones or create new)
              - Frameworks must be from common list OR null
              - Tags MUST match pattern: ^([a-z]+:)?[a-z0-9][a-z0-9-]*$
                Valid examples: "web-scraping", "lang:js", "real-estate", "open-source"
                Invalid examples: "Web-Scraping", "lang:JavaScript", "real_estate", "open source"
              - No language tag should exist if input language was null
              - Classifications should help with discovery and organization
              
              FIX ONLY these specific issues:
              - lang:c# â†’ lang:csharp (special character fix)
              - PascalCase â†’ kebab-case (e.g., "WebScraping" â†’ "web-scraping")
              - Spaces in tags â†’ hyphens (e.g., "open source" â†’ "open-source")
              
              DO NOT CHANGE:
              - lang:js, lang:ts, lang:go, etc. (keep abbreviated language codes AS IS)
              - Valid kebab-case tags
              - Categories that work
              
              If classifications have minor fixable issues (like lang:c# â†’ lang:csharp), FIX THEM and return the corrected JSON.
              Only reject if there are unfixable issues.
              
              Original repo data:
              ${JSON.stringify(repoData, null, 2)}

              AI Classifications:
              ${aiClassificationResult}`;

              // Call validator AI
              console.log('ðŸ¤– Calling validator AI for review...');
              const validationResponse = await github.request('POST /models/openai/gpt-4o/inferences', {
                input: {
                  messages: [
                    { role: 'system', content: 'You are a classification validator. Fix minor issues and return corrected JSON, or reject with specific reasons.' },
                    { role: 'user', content: validationPrompt }
                  ],
                  max_tokens: 2500
                }
              });

              let validationResult = validationResponse.data.choices[0].message.content.trim();
              
              // Strip any markdown formatting if AI didn't follow instructions
              validationResult = validationResult.replace(/^```json\s*/i, '').replace(/\s*```$/i, '').trim();
              console.log('Validation Result:', validationResult);
              
              if (validationResult.startsWith('REJECTED:')) {
                core.setFailed(`AI classifications rejected by validator: ${validationResult}`);
                return;
              } else if (validationResult.startsWith('[')) {
                // Validator provided corrected JSON
                console.log('âœ… Using validator-corrected classifications');
                finalClassifications = validationResult;
              } else {
                // Unexpected response
                core.setFailed(`Unexpected validator response: ${validationResult}`);
                return;
              }
            }
            
            let classifications;
            try {
              classifications = JSON.parse(finalClassifications);
            } catch (error) {
              console.error('Failed to parse classifications as JSON:', error);
              core.setFailed(`Invalid JSON in classifications: ${error.message}`);
              return;
            }
            
            if (!Array.isArray(classifications)) {
              core.setFailed('AI response is not an array');
              return;
            }
            
            if (classifications.length === 0) {
              console.log('No classifications returned');
              core.setOutput('classified_count', 0);
              return;
            }

            // Apply classifications to manifest
            let classifiedCount = 0;
            let notFoundRepos = [];
            
            classifications.forEach(classification => {
              const repoIndex = manifestData.repositories.findIndex(r => r.repo === classification.repo);
              if (repoIndex !== -1) {
                const repo = manifestData.repositories[repoIndex];
                
                // Always update these fields
                repo.categories = classification.categories;
                repo.tags = classification.tags || [];
                
                // Only set non-default values (schema defaults: needs_review=false, framework=null)
                if (classification.framework) {
                  repo.framework = classification.framework;
                } else {
                  // Remove framework if it was previously set but classification is null
                  delete repo.framework;
                }
                
                // Only set needs_review false if it was previously true
                if (repo.needs_review === true) {
                  delete repo.needs_review; // Let it default to false
                }
                
                // Add AI classification metadata for audit trail
                repo.ai_classification = {
                  model: 'openai/gpt-4o',
                  timestamp: new Date().toISOString(),
                  prompt_version: '3.0.0'
                };
                
                classifiedCount++;
                
                console.log(`Classified ${classification.repo}: ${classification.categories.join(', ')}`);
              } else {
                notFoundRepos.push(classification.repo);
              }
            });
            
            if (notFoundRepos.length > 0) {
              console.warn(`âš ï¸ Could not find these repos in manifest: ${notFoundRepos.join(', ')}`);
            }

            // Update metadata
            manifestData.manifest_metadata.last_updated = new Date().toISOString();

            // Write updated manifest
            try {
              fs.writeFileSync('.github-stars/data/manifest.json', JSON.stringify(manifestData, null, 2));
              console.log(`Successfully classified ${classifiedCount} repositories`);
            } catch (error) {
              core.setFailed(`Failed to write classified manifest: ${error.message}`);
              return;
            }

            core.setOutput('classified_count', classifiedCount);
            core.setOutput('repo_count', repoData.length);

      - name: Create validation failure issue
        if: failure() && steps.ai_classify_consolidated.outputs.repo_count != ''
        uses: actions/github-script@v7
        env:
          REPO_COUNT: ${{ steps.ai_classify_consolidated.outputs.repo_count }}
        with:
          script: |
            // Get values from environment to avoid template literal issues
            const repoCount = process.env.REPO_COUNT || '0';
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ðŸ¤– AI Classification Failed (${repoCount} repos)`,
              body: `## AI Classification Failure
              
              **Repositories Affected:**
              ${repoCount} repositories need manual classification.
              
              **Next Steps:**
              1. Check the workflow logs for AI classification details
              2. Manually classify the repositories
              3. Update the classification prompts if needed
              
              cc: @${context.repo.owner}`,
              labels: ['ai-classification', 'validation-failed', 'needs-review']
            });

      - name: Convert classified manifest to YAML
        if: steps.ai_classify_consolidated.outputs.classified_count && steps.ai_classify_consolidated.outputs.classified_count > 0
        run: |
          ./yq eval '.' .github-stars/data/manifest.json -o=yaml > repos.yml

      - name: Clean up temp files
        if: always()
        run: rm -f .github-stars/data/manifest.json

      - name: Validate classified manifest
        if: steps.ai_classify_consolidated.outputs.classified_count && steps.ai_classify_consolidated.outputs.classified_count > 0
        uses: cardinalby/schema-validator-action@v3
        with:
          schema: 'schemas/repos-schema.json'
          file: 'repos.yml'
          mode: 'lax'

      - name: Commit AI classification results
        if: steps.ai_classify_consolidated.outputs.classified_count && steps.ai_classify_consolidated.outputs.classified_count > 0
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add repos.yml
          
          # Determine commit message based on processing mode
          BULK_LIMIT="${{ github.event.inputs.bulk_process_limit }}"
          if [ "$BULK_LIMIT" = "0" ] || [ -z "$BULK_LIMIT" ]; then
            MODE="normal processing"
          else
            MODE="bulk processing (limit: $BULK_LIMIT)"
          fi
          
          git commit -m "ðŸ¤– AI classify ${{ steps.ai_classify_consolidated.outputs.classified_count }} repositories ($MODE) [skip ci]

          - Automatically categorized repositories using AI classification
          - Updated framework detection and tagging
          - Marked classified repos as no longer needing review

          ðŸ¤– Generated with [Claude Code](https://claude.ai/code)

          Co-Authored-By: Claude <noreply@anthropic.com>"
          git push
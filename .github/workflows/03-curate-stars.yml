---
name: 'Curate Starred Repos'

on:
  workflow_dispatch:
  workflow_run:
    workflows: ["Sync Starred Repos"]
    types:
      - completed

permissions:
  contents: write
  pull-requests: write
  issues: write
  models: read

concurrency:
  group: curate-stars-${{ github.ref }}
  cancel-in-progress: false

jobs:
  classify:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository  
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.STARS_TOKEN || secrets.GITHUB_TOKEN }}
          fetch-depth: 2

      - name: Setup environment  
        run: |
          mkdir -p .github-stars/data
          # Download yq locally
          wget -qO ./yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          chmod +x ./yq

      - name: Prepare repositories for AI classification
        id: prep_repos
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            // Check if repos.yml exists
            if (!fs.existsSync('repos.yml')) {
              console.log('repos.yml not found. Nothing to classify.');
              core.setOutput('has_repos', 'false');
              return;
            }
            
            // Read YAML and convert to JSON using yq directly in memory
            const yamlContent = fs.readFileSync('repos.yml', 'utf8');
            const manifestJson = execSync('./yq eval -o=json -', { input: yamlContent, encoding: 'utf8' });
            const manifestData = JSON.parse(manifestJson);

            // Find repositories that need review
            const unclassifiedRepos = manifestData.repositories.filter(repo => 
              repo.needs_review === true && 
              repo.categories.includes('unclassified')
            );

            console.log(`Found ${unclassifiedRepos.length} repositories needing AI classification`);

            if (unclassifiedRepos.length === 0) {
              console.log('No repositories need classification');
              core.setOutput('has_repos', 'false');
              return;
            }
            
            console.log('ðŸ¤– Starting dual-AI classification process:');
            console.log('  1. Primary AI will classify repositories');
            console.log('  2. Validator AI will review classifications');
            console.log('  3. Only approved classifications will be applied');

            // Get original stars data for language info
            const starsDataPath = '.github-stars/data/fetched-stars-graphql.json';
            if (!fs.existsSync(starsDataPath)) {
              core.setFailed('Fetched stars data not found. Please run fetch-stars workflow first.');
              return;
            }
            const starsData = JSON.parse(fs.readFileSync(starsDataPath, 'utf8'));

            // Prepare repo data for AI (get language from original stars data)
            const repoData = unclassifiedRepos.map(repo => {
              const starRepo = starsData ? starsData.find(s => s.repo === repo.repo) : null;
              return {
                repo: repo.repo,
                summary: repo.summary,
                language: starRepo ? starRepo.language : null,
                starred_at: repo.starred_at
              };
            });

            // Write repo data for AI
            fs.writeFileSync('.github-stars/data/repos-to-classify.json', JSON.stringify(repoData, null, 2));
            core.setOutput('has_repos', 'true');
            core.setOutput('repo_count', unclassifiedRepos.length);

      - name: Debug outputs
        run: |
          echo "has_repos output: ${{ steps.prep_repos.outputs.has_repos }}"
          echo "repo_count output: ${{ steps.prep_repos.outputs.repo_count }}"
          
      - name: Check if classification is needed
        if: steps.prep_repos.outputs.has_repos == 'true'
        run: |
          echo "Found repositories to classify"
          if [ ! -f ".github-stars/data/repos-to-classify.json" ]; then
            echo "ERROR: repos-to-classify.json was not created!"
            exit 1
          fi
          echo "Repos to classify:"
          cat .github-stars/data/repos-to-classify.json

      - name: Create system prompt file
        if: steps.prep_repos.outputs.has_repos == 'true'
        run: |
          cat > .github-stars/data/classification-system-prompt.txt << 'EOF'
          You are a repository classification expert. Analyze GitHub repositories and classify them accurately.
          
          Available categories: dev-tools, ui-libraries, frameworks, databases, productivity, learning, documentation, automation, testing, deployment, monitoring, security, ai-ml, data-science, web-dev, mobile-dev, desktop-dev, game-dev, embedded, networking, system-admin, cloud, containers, apis, unclassified
          
          Available frameworks: react, vue, angular, svelte, nextjs, nuxtjs, express, fastapi, django, flask, rails, laravel, spring
          
          Language tags should use namespace format: lang:js, lang:ts, lang:python, lang:rust, lang:go
          
          Return a JSON array with this exact structure for each repository:
          {
            "repo": "owner/name",
            "categories": ["category1", "category2"],
            "tags": ["tag1", "tag2", "lang:language"],
            "framework": "framework-name-or-null"
          }
          
          Rules:
          - Each repo should have 1-3 relevant categories (never just "unclassified" unless truly unclear)
          - Include language tags based on the programming language
          - Framework should be null if not a framework-specific project
          - Be conservative with framework assignment
          - Tags should be lowercase, hyphenated
          EOF

      - name: Read prompts for AI
        id: read_prompts
        if: steps.prep_repos.outputs.has_repos == 'true'
        run: |
          SYSTEM_PROMPT=$(cat .github-stars/data/classification-system-prompt.txt)
          REPOS_DATA=$(cat .github-stars/data/repos-to-classify.json)
          
          # GitHub Actions multiline output
          echo "system_prompt<<EOF" >> $GITHUB_OUTPUT
          echo "$SYSTEM_PROMPT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "prompt<<EOF" >> $GITHUB_OUTPUT
          echo "Please classify the following repositories according to the system prompt instructions:" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "$REPOS_DATA" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
      - name: AI classify repositories  
        id: ai_classify
        if: steps.prep_repos.outputs.has_repos == 'true'
        uses: actions/ai-inference@v1
        with:
          model: 'openai/gpt-4o'
          max-tokens: '2000'
          system-prompt: ${{ steps.read_prompts.outputs.system_prompt }}
          prompt: ${{ steps.read_prompts.outputs.prompt }}

      - name: Create validation prompt
        if: steps.prep_repos.outputs.has_repos == 'true'
        run: |
          cat > .github-stars/data/validation-prompt.txt << 'EOF'
          Review these AI classifications and validate them. Check for:
          1. Categories are appropriate and from the allowed list
          2. Framework assignments are conservative and accurate
          3. Language tags match the actual programming language
          4. Tags are properly formatted (lowercase, hyphenated)
          5. No obvious misclassifications
          
          Return ONLY "APPROVED" if all classifications look correct, or "REJECTED: [specific issues]" if there are problems.
          
          Original repo data:
          EOF
          cat .github-stars/data/repos-to-classify.json >> .github-stars/data/validation-prompt.txt
          echo "" >> .github-stars/data/validation-prompt.txt
          echo "AI Classifications:" >> .github-stars/data/validation-prompt.txt
          echo '${{ steps.ai_classify.outputs.response }}' >> .github-stars/data/validation-prompt.txt

      - name: Validate AI classifications
        id: ai_validate
        if: steps.prep_repos.outputs.has_repos == 'true'
        uses: actions/ai-inference@v1
        with:
          model: 'openai/gpt-4o'
          max-tokens: '500'
          system-prompt: 'You are a classification validator. Be strict about accuracy and only approve classifications that are clearly correct.'
          prompt-file: '.github-stars/data/validation-prompt.txt'

      - name: Apply AI classification results
        id: apply_classification
        if: steps.prep_repos.outputs.has_repos == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            // Check validation result first
            const validationResult = `${{ steps.ai_validate.outputs.response }}`.trim();
            console.log('Validation Result:', validationResult);
            
            if (!validationResult.startsWith('APPROVED')) {
              core.setFailed(`AI classifications rejected by validator: ${validationResult}`);
              return;
            }
            
            console.log('âœ… AI classifications approved by validator');
            
            // Read the AI response
            const aiResponse = `${{ steps.ai_classify.outputs.response }}`;
            console.log('AI Response:', aiResponse);
            
            let classifications;
            try {
              classifications = JSON.parse(aiResponse);
            } catch (error) {
              console.error('Failed to parse AI response as JSON:', error);
              core.setFailed(`AI returned invalid JSON: ${error.message}`);
              return;
            }
            
            if (!Array.isArray(classifications)) {
              core.setFailed('AI response is not an array');
              return;
            }

            // Read current manifest
            const yamlContent = fs.readFileSync('repos.yml', 'utf8');
            const manifestJson = execSync('./yq eval -o=json -', { input: yamlContent, encoding: 'utf8' });
            const manifestData = JSON.parse(manifestJson);

            // Apply classifications
            let classifiedCount = 0;
            classifications.forEach(classification => {
              const repoIndex = manifestData.repositories.findIndex(r => r.repo === classification.repo);
              if (repoIndex !== -1) {
                manifestData.repositories[repoIndex].categories = classification.categories;
                manifestData.repositories[repoIndex].tags = classification.tags || [];
                manifestData.repositories[repoIndex].framework = classification.framework;
                manifestData.repositories[repoIndex].needs_review = false;
                classifiedCount++;
                
                console.log(`Classified ${classification.repo}: ${classification.categories.join(', ')}`);
              }
            });

            // Update metadata
            manifestData.manifest_metadata.last_updated = new Date().toISOString();

            // Write updated manifest
            try {
              fs.writeFileSync('.github-stars/data/manifest.json', JSON.stringify(manifestData, null, 2));
              console.log(`Successfully classified ${classifiedCount} repositories`);
            } catch (error) {
              core.setFailed(`Failed to write classified manifest: ${error.message}`);
              return;
            }

            core.setOutput('classified_count', classifiedCount);

      - name: Create validation failure issue
        if: failure() && steps.ai_validate.outputs.response != ''
        uses: actions/github-script@v7
        with:
          script: |
            const validationResult = `${{ steps.ai_validate.outputs.response }}`;
            const repoCount = `${{ steps.prep_repos.outputs.repo_count }}`;
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ðŸ¤– AI Classification Validation Failed (${repoCount} repos)`,
              body: `## AI Classification Validation Failure
              
              **Validation Result:**
              \`\`\`
              ${validationResult}
              \`\`\`
              
              **Original Classifications:**
              \`\`\`json
              ${{ steps.ai_classify.outputs.response }}
              \`\`\`
              
              **Repositories Affected:**
              ${repoCount} repositories need manual classification.
              
              **Next Steps:**
              1. Review the validation feedback
              2. Manually classify the repositories
              3. Update the classification prompts if needed
              
              cc: @${context.repo.owner}`,
              labels: ['ai-classification', 'validation-failed', 'needs-review']
            });

      - name: Convert classified manifest to YAML
        if: steps.apply_classification.outputs.classified_count > 0
        run: |
          ./yq eval '.' .github-stars/data/manifest.json -o=yaml > repos.yml

      - name: Clean up temp files
        if: always()
        run: rm -f .github-stars/data/manifest.json .github-stars/data/repos-to-classify.json .github-stars/data/classification-system-prompt.txt .github-stars/data/validation-prompt.txt

      - name: Validate classified manifest
        if: steps.apply_classification.outputs.classified_count > 0
        uses: cardinalby/schema-validator-action@v3
        with:
          schema: 'schemas/repos-schema.json'
          file: 'repos.yml'
          mode: 'lax'

      - name: Commit AI classification results
        if: steps.apply_classification.outputs.classified_count > 0
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add repos.yml
          git commit -m "ðŸ¤– AI classify ${{ steps.apply_classification.outputs.classified_count }} repositories [skip ci]

          - Automatically categorized repositories using AI classification
          - Updated framework detection and tagging
          - Marked classified repos as no longer needing review

          ðŸ¤– Generated with [Claude Code](https://claude.ai/code)

          Co-Authored-By: Claude <noreply@anthropic.com>"
          git push
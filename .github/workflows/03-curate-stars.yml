---
name: 'Curate Starred Repos'

on:
  workflow_dispatch:
    inputs:
      skip_validation:
        description: 'Skip AI validation step (cost savings)'
        type: boolean
        default: false
  workflow_run:
    workflows: ["Sync Starred Repos"]
    types:
      - completed

permissions:
  contents: write
  pull-requests: write
  issues: write
  models: read

concurrency:
  group: curate-stars-${{ github.ref }}
  cancel-in-progress: false

jobs:
  classify:
    runs-on: ubuntu-latest
    # Only run if manually triggered or if the triggering workflow succeeded
    if: github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success'

    steps:
      - name: Checkout repository  
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.STARS_TOKEN || secrets.GITHUB_TOKEN }}
          fetch-depth: 0
          ref: main

      - name: Pull latest changes with retry
        run: |
          echo "Ensuring we have the latest changes from workflow 02..."
          # Try to pull up to 3 times with a 5-second delay
          for i in 1 2 3; do
            if git pull origin main; then
              echo "✅ Successfully pulled latest changes"
              break
            else
              echo "⚠️  Pull attempt $i failed, waiting 5 seconds..."
              sleep 5
            fi
          done
          
          # Verify repos.yml exists
          if [ -f "repos.yml" ]; then
            echo "✅ repos.yml found"
            echo "File size: $(ls -lh repos.yml | awk '{print $5}')"
          else
            echo "❌ ERROR: repos.yml not found after pulling latest changes"
            echo "Current directory contents:"
            ls -la
            exit 1
          fi
          
      - name: Setup environment  
        run: |
          mkdir -p .github-stars/data
          # Download yq locally
          wget -qO ./yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          chmod +x ./yq

      - name: Prepare repositories for AI classification
        id: prep_repos
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            // Check if repos.yml exists
            if (!fs.existsSync('repos.yml')) {
              console.log('repos.yml not found. Nothing to classify.');
              core.setOutput('has_repos', 'false');
              return;
            }
            
            // Read YAML and convert to JSON using yq directly in memory
            const yamlContent = fs.readFileSync('repos.yml', 'utf8');
            const manifestJson = execSync('./yq eval -o=json -', { input: yamlContent, encoding: 'utf8' });
            const manifestData = JSON.parse(manifestJson);

            // Find repositories that have never been AI classified AND are marked for review
            const reposToClassify = manifestData.repositories.filter(repo => {
              // Never been AI classified if ai_classification is missing or timestamp is null
              const neverClassified = !repo.ai_classification || !repo.ai_classification.timestamp;
              
              // Must be explicitly marked for review (throttling mechanism)
              const markedForReview = repo.needs_review === true;
              
              // Only classify if BOTH conditions are met
              return neverClassified && markedForReview;
            });

            console.log(`Found ${reposToClassify.length} repositories that have never been AI classified`);
            
            // Log breakdown for debugging
            const totalRepos = manifestData.repositories.length;
            const alreadyClassified = manifestData.repositories.filter(r => r.ai_classification && r.ai_classification.timestamp).length;
            const needsReviewCount = manifestData.repositories.filter(r => r.needs_review === true).length;
            
            console.log(`📊 Repository breakdown:`);
            console.log(`  Total repos: ${totalRepos}`);
            console.log(`  Already AI classified: ${alreadyClassified}`);
            console.log(`  Marked needs_review: ${needsReviewCount}`);
            console.log(`  Ready for classification: ${reposToClassify.length}`);

            if (reposToClassify.length === 0) {
              console.log('No repositories need classification');
              core.setOutput('has_repos', 'false');
              return;
            }
            
            console.log('🤖 Starting dual-AI classification process:');
            console.log('  1. Primary AI will classify repositories');
            console.log('  2. Validator AI will review classifications');
            console.log('  3. Only approved classifications will be applied');

            // Get original stars data for language info
            const starsDataPath = '.github-stars/data/fetched-stars-graphql.json';
            if (!fs.existsSync(starsDataPath)) {
              core.setFailed('Fetched stars data not found. Please run fetch-stars workflow first.');
              return;
            }
            const starsData = JSON.parse(fs.readFileSync(starsDataPath, 'utf8'));

            // Prepare repo data for AI (get language from original stars data)
            const repoData = reposToClassify.map(repo => {
              const starRepo = starsData ? starsData.find(s => s.repo === repo.repo) : null;
              return {
                repo: repo.repo,
                summary: repo.summary,
                language: starRepo ? starRepo.language : null,
                starred_at: repo.starred_at
              };
            });

            // Store repo data directly in output for next steps
            core.setOutput('has_repos', 'true');
            core.setOutput('repo_count', reposToClassify.length);
            core.setOutput('repo_data', JSON.stringify(repoData));

      - name: Debug outputs
        run: |
          echo "has_repos output: ${{ steps.prep_repos.outputs.has_repos }}"
          echo "repo_count output: ${{ steps.prep_repos.outputs.repo_count }}"
          
      - name: Check if classification is needed
        if: steps.prep_repos.outputs.has_repos == 'true'
        run: |
          echo "Found ${{ steps.prep_repos.outputs.repo_count }} repositories to classify"
          echo "Repos to classify:"
          echo '${{ steps.prep_repos.outputs.repo_data }}' | jq .

      - name: Create system prompt file
        if: steps.prep_repos.outputs.has_repos == 'true'
        run: |
          cat > .github-stars/data/classification-system-prompt.txt << 'EOF'
          Classify GitHub repositories thoughtfully. Output ONLY a JSON array.
          
          SUGGESTED CATEGORIES (use these or create more specific ones):
          dev-tools, ui-libraries, frameworks, databases, productivity, learning, documentation, automation, testing, deployment, monitoring, security, ai-ml, data-science, web-dev, mobile-dev, desktop-dev, game-dev, embedded, networking, system-admin, cloud, containers, apis, cli-tools, devops, infrastructure, analytics, visualization, education, media, graphics, audio, video, iot, blockchain, crypto, finance, health, science, math, algorithms, compilers, languages, operating-systems, virtualization, backup, storage, messaging, search, cms, e-commerce, social, communication
          
          COMMON FRAMEWORKS (use if applicable):
          react, vue, angular, svelte, nextjs, nuxtjs, express, fastapi, django, flask, rails, laravel, spring
          
          LANGUAGE TAGS (use these exact formats when language is known):
          lang:js, lang:ts, lang:python, lang:rust, lang:go, lang:csharp, lang:php, lang:dart, lang:lua, lang:gdscript, lang:java, lang:kotlin, lang:swift, lang:ruby, lang:cpp, lang:c
          
          GUIDELINES:
          - Use 2-4 most relevant categories (be generous, repos often fit multiple categories)
          - Add 3-6 descriptive tags that capture the essence of the repo
          - Create new categories if existing ones don't fit well
          - Only set framework if the repo is specifically built with/for that framework
          - Include language tag only when provided in input data
          - Be creative and specific with tags (e.g., "infinite-canvas", "local-first", "markdown-editor")
          - Think about how someone might search for this repo
          
          EXAMPLES OF CORRECT OUTPUT:
          [
            {
              "repo": "microsoft/vscode",
              "categories": ["dev-tools", "productivity", "editors"],
              "tags": ["code-editor", "ide", "extensible", "electron", "lang:ts"],
              "framework": null
            },
            {
              "repo": "facebook/react",
              "categories": ["frameworks", "ui-libraries", "web-dev", "frontend"],
              "tags": ["component-based", "virtual-dom", "jsx", "declarative", "lang:js"],
              "framework": "react"
            },
            {
              "repo": "actions/checkout",
              "categories": ["automation", "devops", "ci-cd"],
              "tags": ["github-actions", "git", "version-control", "workflow", "lang:ts"],
              "framework": null
            },
            {
              "repo": "some/readme-generator",
              "categories": ["documentation", "automation", "dev-tools"],
              "tags": ["markdown", "readme", "generator", "cli"],
              "framework": null
            },
            {
              "repo": "vercel/next.js",
              "categories": ["frameworks", "web-dev", "full-stack"],
              "tags": ["ssr", "react-framework", "jamstack", "serverless", "lang:js"],
              "framework": "nextjs"
            }
          ]
          
          STRICT RULES:
          1. framework: Must be EXACTLY one of the allowed frameworks OR null (not "null" string)
          2. categories: Array of 1-3 strings from ALLOWED CATEGORIES only
          3. tags: Include lang:X tag ONLY if language is provided in input data
          4. If input language is null/empty: DO NOT add any lang: tag (see readme-generator example)
          5. CRITICAL: Output ONLY the JSON array. First character must be [, last character must be ]
          6. DO NOT include any text, markdown formatting, backticks, or explanations
          7. DO NOT say "Here is the classification" or similar phrases
          8. START YOUR RESPONSE WITH [ AND END WITH ]
          EOF

      - name: Read prompts for AI
        id: read_prompts
        if: steps.prep_repos.outputs.has_repos == 'true'
        run: |
          SYSTEM_PROMPT=$(cat .github-stars/data/classification-system-prompt.txt)
          
          # GitHub Actions multiline output
          echo "system_prompt<<EOF" >> $GITHUB_OUTPUT
          echo "$SYSTEM_PROMPT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "prompt<<EOF" >> $GITHUB_OUTPUT
          echo "Please classify the following repositories according to the system prompt instructions:" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo '${{ steps.prep_repos.outputs.repo_data }}' >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
      - name: AI classify repositories  
        id: ai_classify
        if: steps.prep_repos.outputs.has_repos == 'true'
        uses: actions/ai-inference@v1
        with:
          model: 'openai/gpt-4o'
          max-tokens: '2000'
          system-prompt: ${{ steps.read_prompts.outputs.system_prompt }}
          prompt: ${{ steps.read_prompts.outputs.prompt }}

      - name: Create validation prompt
        if: steps.prep_repos.outputs.has_repos == 'true'
        run: |
          cat > .github-stars/data/validation-prompt.txt << 'EOF'
          RESPOND WITH ONE OF:
          1. IF VALID: Output the CORRECTED JSON array (fixing any minor issues)
          2. IF INVALID: Output "REJECTED: [specific issue]"
          
          START YOUR RESPONSE WITH EITHER [ (for JSON) OR "REJECTED:" (for rejection)
          
          Validation criteria:
          - Categories should be relevant and descriptive (can use suggested ones or create new)
          - Frameworks must be from common list OR null
          - Tags MUST match pattern: ^([a-z]+:)?[a-z0-9][a-z0-9-]*$
            Valid examples: "web-scraping", "lang:js", "real-estate", "open-source"
            Invalid examples: "Web-Scraping", "lang:JavaScript", "real_estate", "open source"
          - No language tag should exist if input language was null
          - Classifications should help with discovery and organization
          
          FIX ONLY these specific issues:
          - lang:c# → lang:csharp (special character fix)
          - PascalCase → kebab-case (e.g., "WebScraping" → "web-scraping")
          - Spaces in tags → hyphens (e.g., "open source" → "open-source")
          
          DO NOT CHANGE:
          - lang:js, lang:ts, lang:go, etc. (keep abbreviated language codes AS IS)
          - Valid kebab-case tags
          - Categories that work
          
          If classifications have minor fixable issues (like lang:c# → lang:csharp), FIX THEM and return the corrected JSON.
          Only reject if there are unfixable issues.
          
          Original repo data:
          EOF
          echo '${{ steps.prep_repos.outputs.repo_data }}' >> .github-stars/data/validation-prompt.txt
          echo "" >> .github-stars/data/validation-prompt.txt
          echo "AI Classifications:" >> .github-stars/data/validation-prompt.txt
          echo '${{ steps.ai_classify.outputs.response }}' >> .github-stars/data/validation-prompt.txt

      - name: Read validation prompt
        id: read_validation
        if: steps.prep_repos.outputs.has_repos == 'true'
        run: |
          VALIDATION_PROMPT=$(cat .github-stars/data/validation-prompt.txt)
          
          # GitHub Actions multiline output
          echo "prompt<<EOF" >> $GITHUB_OUTPUT
          echo "$VALIDATION_PROMPT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
      - name: Validate AI classifications
        id: ai_validate
        if: steps.prep_repos.outputs.has_repos == 'true' && github.event.inputs.skip_validation != 'true'
        uses: actions/ai-inference@v1
        with:
          model: 'openai/gpt-4o'
          max-tokens: '2500'
          system-prompt: 'You are a classification validator. Fix minor issues and return corrected JSON, or reject with specific reasons.'
          prompt: ${{ steps.read_validation.outputs.prompt }}

      - name: Apply AI classification results
        id: apply_classification
        if: steps.prep_repos.outputs.has_repos == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            let finalClassifications;
            
            // Check if validation was skipped
            const skipValidation = '${{ github.event.inputs.skip_validation }}' === 'true';
            
            if (skipValidation) {
              console.log('⚠️ Validation skipped - using original AI classifications');
              finalClassifications = String.raw`${{ steps.ai_classify.outputs.response }}`.trim();
              // Strip any markdown formatting if AI didn't follow instructions
              finalClassifications = finalClassifications.replace(/^```json\s*/i, '').replace(/\s*```$/i, '').trim();
            } else {
              // Check validation result - escape backticks to prevent syntax errors
              let validationResult = String.raw`${{ steps.ai_validate.outputs.response }}`.trim();
              
              // Strip any markdown formatting if AI didn't follow instructions
              validationResult = validationResult.replace(/^```json\s*/i, '').replace(/\s*```$/i, '').trim();
              console.log('Validation Result:', validationResult);
              
              if (validationResult.startsWith('REJECTED:')) {
                core.setFailed(`AI classifications rejected by validator: ${validationResult}`);
                return;
              } else if (validationResult.startsWith('[')) {
                // Validator provided corrected JSON
                console.log('✅ Using validator-corrected classifications');
                finalClassifications = validationResult;
              } else {
                // Unexpected response
                core.setFailed(`Unexpected validator response: ${validationResult}`);
                return;
              }
            }
            
            let classifications;
            try {
              classifications = JSON.parse(finalClassifications);
            } catch (error) {
              console.error('Failed to parse classifications as JSON:', error);
              core.setFailed(`Invalid JSON in classifications: ${error.message}`);
              return;
            }
            
            if (!Array.isArray(classifications)) {
              core.setFailed('AI response is not an array');
              return;
            }
            
            if (classifications.length === 0) {
              console.log('No classifications returned');
              core.setOutput('classified_count', 0);
              return;
            }

            // Read current manifest
            const yamlContent = fs.readFileSync('repos.yml', 'utf8');
            const manifestJson = execSync('./yq eval -o=json -', { input: yamlContent, encoding: 'utf8' });
            const manifestData = JSON.parse(manifestJson);

            // Apply classifications
            let classifiedCount = 0;
            let notFoundRepos = [];
            
            classifications.forEach(classification => {
              const repoIndex = manifestData.repositories.findIndex(r => r.repo === classification.repo);
              if (repoIndex !== -1) {
                manifestData.repositories[repoIndex].categories = classification.categories;
                manifestData.repositories[repoIndex].tags = classification.tags || [];
                manifestData.repositories[repoIndex].framework = classification.framework;
                manifestData.repositories[repoIndex].needs_review = false;
                
                // Add AI classification metadata for audit trail
                manifestData.repositories[repoIndex].ai_classification = {
                  model: 'openai/gpt-4o',
                  timestamp: new Date().toISOString(),
                  prompt_version: '3.0.0'
                };
                
                classifiedCount++;
                
                console.log(`Classified ${classification.repo}: ${classification.categories.join(', ')}`);
              } else {
                notFoundRepos.push(classification.repo);
              }
            });
            
            if (notFoundRepos.length > 0) {
              console.warn(`⚠️ Could not find these repos in manifest: ${notFoundRepos.join(', ')}`);
            }

            // Update metadata
            manifestData.manifest_metadata.last_updated = new Date().toISOString();

            // Write updated manifest
            try {
              fs.writeFileSync('.github-stars/data/manifest.json', JSON.stringify(manifestData, null, 2));
              console.log(`Successfully classified ${classifiedCount} repositories`);
            } catch (error) {
              core.setFailed(`Failed to write classified manifest: ${error.message}`);
              return;
            }

            core.setOutput('classified_count', classifiedCount);

      - name: Create validation failure issue
        if: failure() && steps.ai_validate.outputs.response != ''
        uses: actions/github-script@v7
        env:
          VALIDATION_RESULT: ${{ steps.ai_validate.outputs.response }}
          AI_CLASSIFY_RESPONSE: ${{ steps.ai_classify.outputs.response }}
          REPO_COUNT: ${{ steps.prep_repos.outputs.repo_count }}
        with:
          script: |
            // Get values from environment to avoid template literal issues
            const validationResult = process.env.VALIDATION_RESULT || 'No validation result';
            const aiClassifyResponse = process.env.AI_CLASSIFY_RESPONSE || 'No classification response';
            const repoCount = process.env.REPO_COUNT || '0';
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `🤖 AI Classification Validation Failed (${repoCount} repos)`,
              body: `## AI Classification Validation Failure
              
              **Validation Result:**
              \`\`\`
              ${validationResult}
              \`\`\`
              
              **Original Classifications:**
              \`\`\`json
              ${aiClassifyResponse}
              \`\`\`
              
              **Repositories Affected:**
              ${repoCount} repositories need manual classification.
              
              **Next Steps:**
              1. Review the validation feedback
              2. Manually classify the repositories
              3. Update the classification prompts if needed
              
              cc: @${context.repo.owner}`,
              labels: ['ai-classification', 'validation-failed', 'needs-review']
            });

      - name: Convert classified manifest to YAML
        if: steps.apply_classification.outputs.classified_count && steps.apply_classification.outputs.classified_count > 0
        run: |
          ./yq eval '.' .github-stars/data/manifest.json -o=yaml > repos.yml

      - name: Clean up temp files
        if: always()
        run: rm -f .github-stars/data/manifest.json .github-stars/data/classification-system-prompt.txt .github-stars/data/validation-prompt.txt

      - name: Validate classified manifest
        if: steps.apply_classification.outputs.classified_count && steps.apply_classification.outputs.classified_count > 0
        uses: cardinalby/schema-validator-action@v3
        with:
          schema: 'schemas/repos-schema.json'
          file: 'repos.yml'
          mode: 'lax'

      - name: Commit AI classification results
        if: steps.apply_classification.outputs.classified_count && steps.apply_classification.outputs.classified_count > 0
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add repos.yml
          git commit -m "🤖 AI classify ${{ steps.apply_classification.outputs.classified_count }} repositories [skip ci]

          - Automatically categorized repositories using AI classification
          - Updated framework detection and tagging
          - Marked classified repos as no longer needing review

          🤖 Generated with [Claude Code](https://claude.ai/code)

          Co-Authored-By: Claude <noreply@anthropic.com>"
          git push
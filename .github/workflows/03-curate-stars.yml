---
name: 'Curate Starred Repos'

on:
  workflow_dispatch:
    inputs:
      batch_limit:
        description: 'Repos per batch (max 100)'
        type: number
        default: 15
  workflow_run:
    workflows: ["Sync Starred Repos"]
    types:
      - completed

permissions:
  contents: write
  issues: write
  models: read
  actions: write

env:
  BATCH_LIMIT: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.batch_limit || '15' }}

concurrency:
  group: curate-stars-${{ github.ref }}
  cancel-in-progress: false

jobs:
  classify:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success'

    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: main

      - name: Pull latest
        run: |
          for i in 1 2 3; do
            git pull origin main && break || sleep 5
          done
          [ -f "repos.yml" ] || exit 1
          
      - name: Setup
        run: |
          mkdir -p .github-stars/data
          wget -qO ./yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          chmod +x ./yq

      - name: Prepare repos for classification
        id: prep
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            if (!fs.existsSync('repos.yml')) {
              core.setOutput('has_repos', 'false');
              return;
            }
            
            const yaml = fs.readFileSync('repos.yml', 'utf8');
            const json = execSync('./yq eval -o=json -', { input: yaml, encoding: 'utf8', maxBuffer: 50*1024*1024 });
            const data = JSON.parse(json);

            const unclassified = data.repositories.filter(r => 
              r.categories.includes('unclassified') && 
              (r.needs_review || !r.ai_classification?.timestamp)
            );

            const limit = parseInt(process.env.BATCH_LIMIT) || 15;
            if (limit > 100) { core.setFailed('Batch limit max is 100'); return; }
            
            const batch = unclassified.sort((a,b) => new Date(a.starred_at) - new Date(b.starred_at)).slice(0, limit);
            
            console.log(`Processing ${batch.length} of ${unclassified.length} unclassified repos`);
            
            if (batch.length === 0) {
              core.setOutput('has_repos', 'false');
              return;
            }

            const repoData = batch.map(r => ({
              repo: r.repo,
              summary: r.summary,
              language: r.github_metadata?.language || null,
              topics: r.github_metadata?.topics || [],
              stargazers_count: r.github_metadata?.stargazers_count || 0
            }));

            fs.writeFileSync('.github-stars/data/repos-to-classify.json', JSON.stringify(repoData, null, 2));
            core.setOutput('has_repos', 'true');
            core.setOutput('repo_count', batch.length);

      - name: Create prompts
        if: steps.prep.outputs.has_repos == 'true'
        run: |
          cat > .github-stars/data/system-prompt.txt << 'EOF'
          Classify GitHub repos. Output ONLY a JSON array.
          
          CATEGORIES: dev-tools, ui-libraries, frameworks, databases, productivity, learning, documentation, automation, testing, deployment, monitoring, security, ai-ml, data-science, web-dev, mobile-dev, desktop-dev, game-dev, embedded, networking, system-admin, cloud, containers, apis, cli-tools, devops, infrastructure
          
          FRAMEWORKS: react, vue, angular, svelte, nextjs, nuxtjs, express, fastapi, django, flask, rails, laravel, spring
          
          LANGUAGE TAGS: lang:js, lang:ts, lang:python, lang:rust, lang:go, lang:java, lang:kotlin, lang:swift, lang:ruby, lang:cpp, lang:c, lang:csharp, lang:php
          
          RULES:
          - 2-4 categories per repo
          - 3-6 descriptive tags (include lang:X if language provided)
          - framework must be from list above OR null
          - Output ONLY valid JSON array, no markdown, no explanation
          - First char must be [, last char must be ]
          
          EXAMPLE:
          [{"repo":"microsoft/vscode","categories":["dev-tools","productivity"],"tags":["code-editor","extensible","electron","lang:ts"],"framework":null}]
          EOF

      - name: Read prompts
        id: prompts
        if: steps.prep.outputs.has_repos == 'true'
        run: |
          {
            echo "system<<EOF"
            cat .github-stars/data/system-prompt.txt
            echo "EOF"
            echo "user<<EOF"
            echo "Classify these repositories:"
            cat .github-stars/data/repos-to-classify.json
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: AI classify
        id: ai
        if: steps.prep.outputs.has_repos == 'true'
        uses: actions/ai-inference@v1
        with:
          model: 'openai/gpt-4o'
          max-tokens: '3000'
          system-prompt: ${{ steps.prompts.outputs.system }}
          prompt: ${{ steps.prompts.outputs.user }}

      - name: Validate and fix
        id: validate
        if: steps.prep.outputs.has_repos == 'true'
        uses: actions/ai-inference@v1
        with:
          model: 'openai/gpt-4o'
          max-tokens: '3000'
          system-prompt: 'Fix any issues in this classification JSON. Return ONLY the corrected JSON array. If unfixable, return: REJECTED: reason'
          prompt: |
            Validate and fix this classification:
            ${{ steps.ai.outputs.response }}
            
            Rules: tags must be lowercase kebab-case, framework must be from allowed list or null.
            Return corrected JSON array only.

      - name: Apply classifications
        id: apply
        if: steps.prep.outputs.has_repos == 'true'
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            let result = `${{ steps.validate.outputs.response }}`.trim().replace(/^```json\s*/i, '').replace(/\s*```$/i, '');
            
            if (result.startsWith('REJECTED:')) {
              core.setFailed(result);
              return;
            }
            
            let classifications;
            try {
              classifications = JSON.parse(result);
            } catch (e) {
              core.setFailed(`Invalid JSON: ${e.message}`);
              return;
            }
            
            if (!Array.isArray(classifications) || classifications.length === 0) {
              core.setFailed('Empty or invalid classifications');
              return;
            }

            const yaml = fs.readFileSync('repos.yml', 'utf8');
            const json = execSync('./yq eval -o=json -', { input: yaml, encoding: 'utf8', maxBuffer: 50*1024*1024 });
            const data = JSON.parse(json);

            let count = 0;
            for (const c of classifications) {
              const idx = data.repositories.findIndex(r => r.repo === c.repo);
              if (idx !== -1) {
                data.repositories[idx].categories = c.categories;
                data.repositories[idx].tags = c.tags || [];
                data.repositories[idx].framework = c.framework;
                data.repositories[idx].needs_review = false;
                data.repositories[idx].ai_classification = {
                  model: "gpt-4o",
                  timestamp: new Date().toISOString(),
                  prompt_version: "v2"
                };
                count++;
                console.log(`Classified: ${c.repo}`);
              }
            }

            data.manifest_metadata.last_updated = new Date().toISOString();
            fs.writeFileSync('.github-stars/data/manifest.json', JSON.stringify(data, null, 2));
            core.setOutput('count', count);

      - name: Create issue on failure
        if: failure() && steps.validate.outputs.response
        uses: actions/github-script@v8
        with:
          script: |
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `AI Classification Failed`,
              body: `Validation result:\n\`\`\`\n${process.env.RESULT}\n\`\`\``,
              labels: ['ai-classification', 'needs-review']
            });
        env:
          RESULT: ${{ steps.validate.outputs.response }}

      - name: Convert to YAML
        if: steps.apply.outputs.count > 0
        run: ./yq eval '.' .github-stars/data/manifest.json -o=yaml > repos.yml

      - name: Cleanup
        if: always()
        run: rm -f .github-stars/data/*.json .github-stars/data/*.txt

      - name: Validate
        if: steps.apply.outputs.count > 0
        uses: cardinalby/schema-validator-action@v3
        with:
          schema: 'schemas/repos-schema.json'
          file: 'repos.yml'
          mode: 'lax'

      - name: Commit
        if: steps.apply.outputs.count > 0
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add repos.yml
          git commit -m "AI classify ${{ steps.apply.outputs.count }} repositories [skip ci]"
          git push

      - name: Check remaining
        id: remaining
        if: steps.apply.outputs.count > 0
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            const yaml = fs.readFileSync('repos.yml', 'utf8');
            const json = execSync('./yq eval -o=json -', { input: yaml, encoding: 'utf8', maxBuffer: 50*1024*1024 });
            const data = JSON.parse(json);
            
            const remaining = data.repositories.filter(r => 
              r.categories.includes('unclassified') && 
              (r.needs_review || !r.ai_classification?.timestamp)
            ).length;
            
            console.log(`Remaining: ${remaining}`);
            core.setOutput('count', remaining);
            core.setOutput('has_more', remaining > 0);

      - name: Trigger next batch
        if: steps.remaining.outputs.has_more == 'true'
        uses: actions/github-script@v8
        with:
          script: |
            console.log(`Triggering next batch for ${{ steps.remaining.outputs.count }} remaining repos`);
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: '03-curate-stars.yml',
              ref: 'main',
              inputs: { batch_limit: '${{ env.BATCH_LIMIT }}' }
            });

      - name: Summary
        if: always()
        run: |
          echo "Classified: ${{ steps.apply.outputs.count || 0 }}"
          echo "Remaining: ${{ steps.remaining.outputs.count || 'N/A' }}"
